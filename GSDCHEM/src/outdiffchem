diff -rBbw chem/chemCap.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/chemCap.F90
429c429,430
<     call chem_io_init(verbose=btest(verbosity,0), rc=rc)
---
> !    call chem_io_init(verbose=btest(verbosity,0), rc=rc)
>     call chem_io_init(verbose=.false., rc=rc)
653a655,657
>     logical :: chemoutput=.false. ! ajl 
>     integer mype                  ! ajl 
> 
664a669,670
>     call chem_comm_get(localpe=mype) ! ajl 
> 
674c680
<     
---
>     if(mype.eq.0)then   
680a687
>     endif
687a695
>     if(mype.eq.0)then   
693a702
>     endif
723a733
>     if(chemoutput)then
732a743
>       end if
diff -rBbw chem/chem_methods.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/chem_methods.F90
35a36,37
> !          write(6,*)'gocart_model_init'
> !          call flush(6)
65a68,71
>     integer mype ! ajl 
>     integer mmype
>     common/at/mmype ! ajl
> 
78a85,88
>     call chem_comm_get(localpe=mype) ! ajl 
>     mmype=mype ! ajl
> !    write(6,*)'top gocart advance',mype
> !    call flush(6)
80a91
>     if(mype.eq.0)then
86a98
>     endif
481a494
>     logical :: docheck=.false.
558a572
>       if(docheck)then
560a575
>       endif
Binary files chem/chm.mod and /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/chm.mod differ
diff -rBbw chem/dep/dep_ctrans_grell_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/dep/dep_ctrans_grell_mod.F90
76c76
<         OUTT,OUTQ,OUTQC,rho,zz,dz
---
>         OUTT,OUTQ,OUTQC,rho,zz
135d134
<          dz(I,K)=dz8w(i,k,j)
217,222c216
<              !wet deposition into ug/m2/s
<              !trfall(i,j,nv)=trdep(i,nv) !lzhang
<              do k=kts,kte
<              trfall(i,j,nv)=trfall(i,j,nv)+(tracert(i,k,nv)*rho(i,k)*dz(i,k)) !lzhang 
<              enddo
<              trfall(i,j,nv)=max(0.,trfall(i,j,nv))  !lzhang
---
>              trfall(i,j,nv)=trdep(i,nv) !lzhang
1196d1188
<                       chem_psum(i,nv)=chem_psum(i,nv)*xmb(i) !lzhang
diff -rBbw chem/dep/dep_dry_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/dep/dep_dry_mod.F90
246c246
<           ddep(i,j,nv) = max(0.0, factor * chem(i,kts,j,nv)) & !ug/m2/s
---
>           ddep(i,j,nv) = max(0.0, factor * chem(i,kts,j,nv)) &
diff -rBbw chem/dep/dep_wet_ls_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/dep/dep_wet_ls_mod.F90
19a20
>   public :: new_WetRemovalGOCART
30a32,39
> !   ajl beg
>     character *10 cenv 
>     real newalpha
>     logical first
>     data first/.true./
>     save first
>     integer mype
>     common /at/mype
54,65c63,119
<             !alpha(p_so2   ) = 0.3
<             !alpha(p_msa   ) = 0.3
<             !alpha(p_dms   ) = 0.3
<             alpha(p_sulf) = 0.5
<             alpha(p_bc1) = 0.3
<             alpha(p_oc1) = 0.3
<             alpha(p_dust_1) = 0.3
<             alpha(p_dust_1) = 0.3
<             alpha(p_dust_2) = 0.3
<             alpha(p_dust_3) = 0.3
<             alpha(p_dust_4) = 0.3
<             alpha(p_dust_5) = 0.3
---
> ! ajl beg
>             call getenv('WRFCHEMALPHA',cenv)
>             if(cenv.eq.'YES')then
> #ifdef DIAGWET
>               if(first)then
>                 if(mype.eq.0) write(6,*)'set wrfchemalpha'
>               endif
> #endif
>               alpha(p_bc1)=0.
>               alpha(p_oc1)=0.
> !              alpha(p_dms)=0.
>               alpha(p_bc2)=.8
>               alpha(p_oc2)=.8
>               alpha(p_sulf)=1.
>               alpha(p_seas_1)=1.
>               alpha(p_seas_2)=1.
>               alpha(p_seas_3)=1.
>               alpha(p_seas_4)=1.
>               alpha(p_seas_5)=1.
>               alpha(p_dust_1)=.5
>               alpha(p_dust_2)=.5
>               alpha(p_dust_3)=.5
>               alpha(p_dust_4)=.5
>               alpha(p_dust_5)=.5
>               alpha(p_p10)=.5
>               alpha(p_p25)=.5
>               if(first)then
>                    first=.false.
> #ifdef DIAGWET
>                  if(mype.eq.0)then
>                  do n=1,config%num_chem
>                    if(alpha(n)/=0.0)then
>                       write(6,*)'alpha',n,alpha(n)
>                    endif
>                  end do
>                  endif
> #endif
> 
>               endif
>             else
>               call getenv('WETDEPALPHA',cenv) ! ajl
>               if(cenv.eq.' ')then
>                 alpha = 1.0
>               else
>                 read(cenv,*)newalpha
>                 alpha=newalpha
>                 if(first)then
> #ifdef DIAGWET
>                    if(mype.eq.0)then
>                    write(6,*)'new alpha',newalpha
>                    endif
> #endif
>                    first=.false.
>                 endif
>               endif !ajl
>             endif
> ! ajl end
129c183
<   subroutine wetdep_ls(dt,var,rain,moist,rho,var_rmv,lat,       &
---
>   subroutine wetdep_ls(dt,var,rain,moist,rho,var_rmv,           &
151c205
<     REAL,  DIMENSION( its:ite ,  jts:jte ) :: var_sum,lat
---
> !    REAL,  DIMENSION( its:ite ,  jts:jte ) :: var_sum
154c208
<     real :: dvar,factor,rho_water,ff
---
>     real :: dvar,factor,rho_water
155a210,236
> !   ajl beg
>     REAL,  DIMENSION( its:ite ,  jts:jte ) :: var_sum_clw_wrf
>     real :: newfrc,dvar_wrf
>     logical first,dowetdeplswrf
>     data first/.true./
>     save first,dowetdeplswrf
>     character *10 cenv
>     integer mype
>     common /at/mype
>     if(first)then
>       cenv=' '
>       call getenv('WETDEPLSWRF',cenv)
>       if(cenv.eq.'YES')then
>         dowetdeplswrf=.true.
> #ifdef DIAGWETDEP
>        if(mype.eq.0)then
>         write(6,*)'gsdchem dowetdeplswrfchem'
>        endif
> #endif
> 
>       else
>         dowetdeplswrf=.false.
>       endif
>       cenv=' '
>     endif
> 
> !   ajl end
167,170c249
<     !frc(:,:)=0.1
<     !frc(:,:)=0.01 !lzhang
<     ff=1.0
<     if (nv>=p_seas_1 .and. nv<=p_seas_5) ff=1.6
---
>     if(dowetdeplswrf)then
174c253
<      var_sum(i,j)=0.
---
>           var_sum_clw_wrf(i,j)=0.
178c257
<      if(rain(i,j).gt.1.e-10)then
---
>           if(rain(i,j).gt.1.e-6)then
183a263,274
>              do k=1,kte-1
>                dvar=max(0.,(moist(i,k,j,p_qc)+moist(i,k,j,p_qi))*rho(i,k,j)*vvel(i,k,j)*dz8w(i,k,j))
>                var_sum_clw_wrf(i,j)=var_sum_clw_wrf(i,j)+dvar
>              end do
> !            var_sum_clw_wrf can be zero since vvel could be negative where have
> !            cloud water
>              if ( var_sum_clw(i,j).gt.1.e-10 ) then
>                frc(i,j)=rain_clw(i,j)/var_sum_clw_wrf(i,j)
> !               write(6,*)'gsdchem frc ',
> !               frc(i,j),var_sum_clw_wrf(i,j),'rain_clw',rain_clw(i,j)
>                frc(i,j)=max(1.e-6,min(frc(i,j),.005))
>              endif
187d278
<            var_sum(i,j)=var_sum(i,j)+var(i,k,j,nv)*rho(i,k,j) !lzhang
189,197d279
<            if(var_sum(i,j).gt.1.e-10 .and. var_sum_clw(i,j).gt.1.e-10 ) then
<    !        assuming that frc is onstant, it is my conversion factor 
< !       (just like in convec. parameterization
<               frc(i,j)=rain_clw(i,j)/var_sum_clw(i,j)
< !    write(0,*)'frc ', frc(i,j),var_sum_clw(i,j),var_sum(i,j)
<               if (lat(i,j)<=-55.) then
<               frc(i,j)=max(1.e-6,min(frc(i,j),.005)*ff*10.)
<               else
<               frc(i,j)=max(1.e-6,min(frc(i,j),.005)*ff)
198a281,292
>         enddo
>       enddo
>     else
>       call getenv('WETDEPLSFRC',cenv)
> !      frc(:,:)=0.1
>       if(cenv.ne.' ')then
>         read(cenv,*)newfrc
>         frc(:,:)=newfrc
>         if(first)print *,'newfrc wetdep',newfrc
>         first=.false.
>       else
>         frc(:,:)=0.1
199a294,308
>       do i=its,ite
>         do j=jts,jte
>           var_sum_clw(i,j)=0.
>           var_rmvl(i,:,j)=0.
>           rain_clw(i,j)=0.
>           if(rain(i,j).gt.1.e-6)then
> !            convert rain back to rate
> !
>              rain_clw(i,j)=rain(i,j)/dt
> !            total cloud water
> !
>              do k=1,kte
>                dvar=max(0.,(moist(i,k,j,p_qc)+moist(i,k,j,p_qi)))
>                var_sum_clw(i,j)=var_sum_clw(i,j)+dvar
>             enddo
202a312
>     endif
208c318
<      if(rain(i,j).gt.1.e-10 .and. var_sum(i,j).gt.1.e-10 .and. var_sum_clw(i,j).gt.1.e-10 ) then
---
>      if(rain(i,j).gt.1.e-6 .and. var_sum_clw(i,j).gt.1.e-10 ) then
210c320
<         if(var(i,k,j,nv).gt.1.e-10 .and. (moist(i,k,j,p_qc)+moist(i,k,j,p_qi)).gt.1.e-10)then
---
>         if(var(i,k,j,nv).gt.1.e-08 .and. (moist(i,k,j,p_qc)+moist(i,k,j,p_qi)).gt.1.e-8)then
217d326
<            var_rmvl(i,k,j)=dvar !lzhang
222,224c331
<         !var_rmv(i,j,nv)=var_rmv(i,j,nv)+var_rmvl(i,k,j)
<         !!convert wetdeposition into ug/m2/s  
<         var_rmv(i,j,nv)=var_rmv(i,j,nv)+(var_rmvl(i,k,j)*rho(i,k,j)*dz8w(i,k,j)/dt) !lzhang
---
>         var_rmv(i,j,nv)=var_rmv(i,j,nv)+var_rmvl(i,k,j)
227d333
<        var_rmv(i,j,nv)=max(0.,var_rmv(i,j,nv))
231a338
>     first=.false.
337,338c444,452
<       !pdog(i,k1:k2,j) = (ple(i,k1+1:k2+1,j)-ple(i,k1:k2,j)) / grav
<       pdog(i,k1:k2,j) = (ple(i,k1:k2,j)-ple(i,k1+1:k2+1,j)) / grav !lzhang
---
>       pdog(i,k1:k2,j) = (ple(i,k1+1:k2+1,j)-ple(i,k1:k2,j)) / grav
> !      if(i.eq.47.and.j.eq.5)then
> !        write(6,*)'precl',precl(i,j),precc(i,j)
> !        call flush(6)
> !        do k=k1,k2
> !        write(6,*)'pdog',i,k,j,pdog(i,k,j),ple(i,k+1,j),ple(i,k,j)
> !        end do
> !        call flush(6)
> !      endif
361,362c475,894
<      !LH = 0
<      LH = k2+1 !lzhang
---
>      LH = 0
>      do k = k1, k2
>       if(dqcond(i,k,j) .lt. 0. .and. tmpu(i,k,j) .gt. 258.) then
>        LH = k
>        goto 15
>       endif
>      end do
>  15  continue
>      if(LH .lt. 1) goto 100
> 
> !    convert dqcond from kg water/kg air/s to kg water/m3/s and reverse
> !    sign so that dqcond < 0. (positive precip) means qls and qcv > 0.
> !     if(i.eq.47.and.j.eq.5)then
> !       write(6,*)'precl',precl(i,j),precc(i,j)
>        !call flush(6)
> !     endif
>      do k = LH, k2
>       qls(k) = -dqcond(i,k,j)*pls/pac*rhoa(i,k,j)
>       qcv(k) = -dqcond(i,k,j)*pcv/pac*rhoa(i,k,j)
> !      if(i.eq.47.and.j.eq.5)then
> !        write(6,*)'qls',k,qls(k),qcv(k)
> !      endif
>      end do
> 
> !    Loop over vertical to do the scavenging!
>      do k = LH, k2
> 
> !-----------------------------------------------------------------------------
> !   (1) LARGE-SCALE RAINOUT:
> !       Tracer loss by rainout = TC0 * F * exp(-B*dt)
> !         where B = precipitation frequency,
> !               F = fraction of grid box covered by precipitating clouds.
> !       We assume that tracer scavenged by rain is falling down to the
> !       next level, where a fraction could be re-evaporated to gas phase
> !       if Qls is less then 0 in that level.
> !-----------------------------------------------------------------------------
>       if (qls(k) .gt. 0.) then
>        F  = F0_ls / (1. + F0_ls*B0_ls*XL_ls/(qls(k)*cdt/Td_ls))
>        B  = B0_ls/F0_ls +1./(F0_ls*XL_ls/qls(k))
>        BT = B * Td_ls
>        if (BT.gt.10.) BT = 10.               !< Avoid overflow >
> !      Adjust du level:
>        do n = 1, nbins
>         effRemoval = alpha(nv)
>         DC(n) = chem(i,k,j,nv) * F * effRemoval *(1.-exp(-BT))
>         if (DC(n).lt.0.) DC(n) = 0.
>         chem(i,k,j,nv) = chem(i,k,j,nv)-DC(n)
>         if (chem(i,k,j,nv) .lt. 1.0E-32) chem(i,k,j,nv) = 1.0E-32
>        end do
> !      Flux down:  unit is kg m-2
> !      Formulated in terms of production in the layer.  In the revaporation step
> !      we consider possibly adding flux from above...
>        do n = 1, nbins
>         Fd(k,n) = DC(n)*pdog(i,k,j)
>        end do
> 
>       end if                                    ! if Qls > 0  >>>
> 
> !-----------------------------------------------------------------------------
> ! * (2) LARGE-SCALE WASHOUT:
> ! *     Occurs when rain at this level is less than above.
> !-----------------------------------------------------------------------------
>       if(k .gt. LH .and. qls(k) .ge. 0.) then
>        if(qls(k) .lt. qls(k-1)) then
> !       Find a maximum F overhead until the level where Qls<0.
>         Qmx   = 0.
>         do kk = k-1,LH,-1
>          if (Qls(kk).gt.0.) then
>           Qmx = max(Qmx,Qls(kk))
>          else
>           goto 333
>          end if
>         end do
> 
>  333    continue
>         F = F0_ls / (1. + F0_ls*B0_ls*XL_ls/(Qmx*cdt/Td_ls))
>         if (F.lt.0.01) F = 0.01
> !-----------------------------------------------------------------------------
> !  The following is to convert Q(k) from kgH2O/m3/sec to mm/sec in order
> !  to use the Harvard formula.  Convert back to mixing ratio by multiplying
> !  by rhoa.  Multiply by pdog gives kg/m2/s of precip.  Divide by density
> !  of water (=1000 kg/m3) gives m/s of precip and multiply by 1000 gives
> !  units of mm/s (omit the multiply and divide by 1000).
> !-----------------------------------------------------------------------------
> 
>         Qd = Qmx /rhoa(i,k,j)*pdog(i,k,j)
>         if (Qd.ge.50.) then
>          B = 0.
>         else
>          B = Qd * 0.1
>         end if
>         BT = B * cdt
>         if (BT.gt.10.) BT = 10.
> 
> !       Adjust du level:
>         do n = 1, nbins
>          DC(n) = chem(i,k,j,nv) * F * (1.-exp(-BT))
>          if (DC(n).lt.0.) DC(n) = 0.
>          chem(i,k,j,nv) = chem(i,k,j,nv)-DC(n)
>          if (chem(i,k,j,nv) .lt. 1.0E-32) &
>           chem(i,k,j,nv) = 1.0E-32
>           var_rmv(i,j,nv) = var_rmv(i,j,nv)+DC(n)*pdog(i,k,j)/cdt
>         end do
> 
>        end if
>       end if                                    ! if ls washout  >>>
> #if 0
> !-----------------------------------------------------------------------------
> !  (3) CONVECTIVE RAINOUT:
> !      Tracer loss by rainout = dd0 * F * exp(-B*dt)
> !        where B = precipitation frequency,
> !              F = fraction of grid box covered by precipitating clouds.
> !-----------------------------------------------------------------------------
> 
>       if (qcv(k) .gt. 0.) then
>        F  = F0_cv / (1. + F0_cv*B0_cv*XL_cv/(Qcv(k)*cdt/Td_cv))
>        B  = B0_cv
>        BT = B * Td_cv
>        if (BT.gt.10.) BT = 10.               !< Avoid overflow >
> 
> !      Adjust du level:
>        do n = 1, nbins
>         effRemoval = alpha(nv)
>         DC(n) = chem(i,k,j,nv) * F * effRemoval * (1.-exp(-BT))
>         if (DC(n).lt.0.) DC(n) = 0.
>         chem(i,k,j,nv) = chem(i,k,j,nv)-DC(n)
>         if (chem(i,k,j,nv) .lt. 1.0E-32) chem(i,k,j,nv) = 1.0E-32
>        end do
> 
> !------  Flux down:  unit is kg. Including both ls and cv.
>        do n = 1, nbins
>         Fd(k,n) = Fd(k,n) + DC(n)*pdog(i,k,j)
>        end do
> 
>       end if                                  ! if Qcv > 0   >>>
> 
> !-----------------------------------------------------------------------------
> !  (4) CONVECTIVE WASHOUT:
> !      Occurs when rain at this level is less than above.
> !-----------------------------------------------------------------------------
> 
>       if (k.gt.LH .and. Qcv(k).ge.0.) then
>        if (Qcv(k).lt.Qcv(k-1)) then
> !-----  Find a maximum F overhead until the level where Qls<0.
>         Qmx   = 0.
>         do kk = k-1, LH, -1
>          if (Qcv(kk).gt.0.) then
>           Qmx = max(Qmx,Qcv(kk))
>          else
>           goto 444
>          end if
>         end do
> 
>  444    continue
>         F = F0_cv / (1. + F0_cv*B0_cv*XL_cv/(Qmx*cdt/Td_cv))
>         if (F.lt.0.01) F = 0.01
> !-----------------------------------------------------------------------------
> !  The following is to convert Q(k) from kgH2O/m3/sec to mm/sec in order
> !  to use the Harvard formula.  Convert back to mixing ratio by multiplying
> !  by rhoa.  Multiply by pdog gives kg/m2/s of precip.  Divide by density
> !  of water (=1000 kg/m3) gives m/s of precip and multiply by 1000 gives
> !  units of mm/s (omit the multiply and divide by 1000).
> !-----------------------------------------------------------------------------
> 
>         Qd = Qmx / rhoa(i,k,j)*pdog(i,k,j)
>         if (Qd.ge.50.) then
>          B = 0.
>         else
>          B = Qd * 0.1
>         end if
>         BT = B * cdt
>         if (BT.gt.10.) BT = 10.
> 
> !       Adjust du level:
>         do n = 1, nbins
>          DC(n) = chem(i,k,j,nv) * F * (1.-exp(-BT))
>          if (DC(n).lt.0.) DC(n) = 0.
>          chem(i,k,j,nv) = chem(i,k,j,nv)-DC(n)
>          if (chem(i,k,j,nv) .lt. 1.0E-32) &
>           chem(i,k,j,nv) = 1.0E-32
>           var_rmv(i,j,nv) = var_rmv(i,j,nv)+DC(n)*pdog(i,k,j)/cdt
>         end do
> 
>        end if
>       end if                                    ! if cv washout  >>>
> #endif
> !-----------------------------------------------------------------------------
> !  (5) RE-EVAPORATION.  Assume that SO2 is re-evaporated as SO4 since it
> !      has been oxidized by H2O2 at the level above.
> !-----------------------------------------------------------------------------
> !     Add in the flux from above, which will be subtracted if reevaporation occurs
>       if(k .gt. LH) then
>        do n = 1, nbins
>         Fd(k,n) = Fd(k,n) + Fd(k-1,n)
>        end do
> 
> !      Is there evaporation in the currect layer?
>        if (-dqcond(i,k,j) .lt. 0.) then
> !       Fraction evaporated = H2O(k)evap / H2O(next condensation level).
>         if (-dqcond(i,k-1,j) .gt. 0.) then
> 
>           A =  abs(  dqcond(i,k,j) * pdog(i,k,j)    &
>             /      ( dqcond(i,k-1,j) * pdog(i,k-1,j))  )
>           if (A .gt. 1.) A = 1.
> 
> !         Adjust tracer in the level
>           do n = 1, nbins
>            DC(n) =  Fd(k-1,n) / pdog(i,k,j) * A
>            chem(i,k,j,nv) = chem(i,k,j,nv) + DC(n)
>            chem(i,k,j,nv) = max(chem(i,k,j,nv),1.e-32)
> !          Adjust the flux out of the bottom of the layer
>            Fd(k,n)  = Fd(k,n) - DC(n)*pdog(i,k,j)
>           end do
> 
>         endif
>        endif                                   ! if -moistq < 0
>       endif
>      end do  ! k
> 
>      do n = 1, nbins
> !      if(i.eq.47.and.j.eq.5)then
> !        write(6,*)'var_rmv nv',nv,var_rmv(i,j,nv),k2,Fd(k2,n),cdt
> !      endif
>        var_rmv(i,j,nv) = var_rmv(i,j,nv)+Fd(k2,n)/cdt
>      end do
> 
>  100 continue
>     end do   ! i
>    end do    ! j
>    end do    !nv for num_chem
> 
>    deallocate(fd,DC,stat=ios)
>    if (chem_rc_test((ios .ne. 0), msg="Failed to deallocate memory", &
>      file=__FILE__, line=__LINE__, rc=rc)) return
> 
>    end subroutine WetRemovalGOCART
> 
>   subroutine new_WetRemovalGOCART ( i1, i2, j1, j2, k1, k2, n1, n2, cdt, &
>                                 num_chem, var_rmv, chem, ple, tmpu,  &
>                                 rhoa, dqcond, precc,precl,         &
>                                 ims, ime, jms, jme, kms, kme, rc )
> 
> ! !USES:
>    use chem_rc_mod
>    use chem_types_mod
>    use chem_const_mod, only : grav => grvity
> 
>    IMPLICIT NONE
> 
> ! !INPUT PARAMETERS:
>    integer, intent(in) :: i1, i2, j1, j2, k1, k2, n1, n2, num_chem, &
>                           ims, ime, jms, jme, kms, kme
>    real, intent(in)    :: cdt
>    REAL(CHEM_KIND_R4),  DIMENSION( ims:ime , kms:kme , jms:jme ,1:num_chem),&
>           INTENT(INOUT) :: chem
>    REAL(CHEM_KIND_R4),  DIMENSION( ims:ime ,  jms:jme,num_chem ), &
>           INTENT(INOUT   ) :: var_rmv !! tracer loss flux [kg m-2 s-1]
>    real(CHEM_KIND_R4), dimension(ims:ime, kms:kme, jms:jme),&
>           INTENT(IN)     :: ple, tmpu, rhoa, dqcond
>    real(CHEM_KIND_R4), dimension(ims:ime ,  jms:jme) , &
>           INTENT(IN)      ::  precl    ! cv, ls precip [mm day-1]
>    real(CHEM_KIND_R4), dimension(ims:ime ,  jms:jme) , &
>           INTENT(IN)    :: precc    ! cv, ls precip [mm day-1]
> 
> ! !OUTPUT PARAMETERS:
>    integer, intent(out)             :: rc          ! Error return code:
>                                                    !  0 - all is well
>                                                    !  1 -
> 
> ! !DESCRIPTION: Calculates the updated species concentration due to wet
> !               removal.  As written, intended to function for large
> !               scale (not convective) wet removal processes
> 
> !
> ! !REVISION HISTORY:
> !
> !  08Jan2010 - Colarco, based on GOCART implementation, does not
> !                       include any size dependent term
> !
> !EOP
> !-------------------------------------------------------------------------
> 
> ! !Local Variables
>    character(len=*), parameter :: myname = 'WetRemovalGOCART'
>    integer  ::  i, j, k, n, nbins, LH, kk, ios,nv
>    real(CHEM_KIND_R4) :: pdog(i1:i2,k1:k2,j1:j2)      ! air mass factor dp/g [kg m-2]
>    real :: pls, pcv, pac             ! ls, cv, tot precip [mm day-1]
>    real :: qls(k1:k2), qcv(k1:k2)          ! ls, cv portion dqcond [kg m-3 s-1]
>    real :: qmx, qd, A                ! temporary variables on moisture
>    real :: F, B, BT                  ! temporary variables on cloud, freq.
>    real, allocatable :: fd(:,:)      ! flux across layers [kg m-2]
>    real, allocatable :: DC(:)        ! scavenge change in mass mixing ratio
> !  Rain parameters from Liu et al.
>    real, parameter :: B0_ls = 1.0e-4
>    real, parameter :: F0_ls = 1.0
>    real, parameter :: XL_ls = 5.0e-4
>    real, parameter :: B0_cv = 1.5e-3
>    real, parameter :: F0_cv = 0.3
>    real, parameter :: XL_cv = 2.0e-3
> !  Duration of rain: ls = model timestep, cv = 1800 s (<= cdt)
>    real            :: Td_ls
>    real            :: Td_cv
>    logical bottop
>    integer nmask,kbota(i1:i2),ktopa(i1:i2),kbot,ktop,kinc
> !   real t2d(i1:i2,k1:k2)
> #ifdef WETDEPDIAG
>    REAL(CHEM_KIND_R4),  DIMENSION( i1:i2 ,  k1:k2, j1:j2 ) :: var_rmvl
> #endif
>    real dval
> 
> 
> !  Efficiency of dust wet removal (since dust is really not too hygroscopic)
> !  Applied only to in-cloud scavenging
>    real :: effRemoval
> !  real,dimension(20) ::fwet
> !  tracer: p_so2=1 p_sulf=2 p_dms=3 p_msa=4 p_p25=5 p_bc1=6 p_bc2=7 p_oc1=8
> !  p_oc2=9 p_dust_1=10 p_dust_2=11 p_dust_3=12 p_dust_4=13 p_dust_5=14
> !  p_seas_1=15 p_seas_2=16 p_seas_3=17 p_seas_4=18 p_seas_5=19 p_p10  =20
> !   data fwet /0.,1.5,0.,0.,1.,0.7,0.7,0.4,0.4,1.,1.,1.,1.,1.,1.,1.,1.,1.,1.,1./
> !  rc=0.
> 
> !  Initialize local variables
> !  --------------------------
>    rc = CHEM_RC_SUCCESS
> !   write(6,*)'top wetdeplsnew'
> !   call flush(6)
> !   write(6,*)'top newwetdep',num_chem
> !   call flush(6)
> 
>    Td_ls = cdt
>    Td_cv = cdt
>    nbins = n2-n1+1
>    var_rmv = 0.0
> 
> !  Allocate the dynamic arrays
>    allocate(fd(k1:k2,nbins),stat=ios)
>    if (chem_rc_test((ios .ne. 0), msg="Failed to allocate memory", &
>      file=__FILE__, line=__LINE__, rc=rc)) return
>    allocate(dc(nbins),stat=ios)
>    if (chem_rc_test((ios .ne. 0), msg="Failed to allocate memory", &
>      file=__FILE__, line=__LINE__, rc=rc)) return
> 
> !  Accumulate the 3-dimensional arrays of rhoa and pdog
>    if(ple(i1,k1,j1)>ple(i1,k2,j2))then
> !    k1 is bottom
>      kbot=k1
>      ktop=k2
>      kinc=-1
>      bottop=.true.
>    else
>      kbot=k2
>      ktop=k1
>      kinc=1
>      bottop=.false.
>    end if
>    do j = j1, j2
>     do i = i1, i2
>       if(bottop)then
>         do k=k1,k2
>          pdog(i,k,j)=(ple(i,k,j)-ple(i,k+1,j))/grav
>         end do
>       else
>         do k=k1,k2
>          pdog(i,k,j)=(ple(i,k+1,j)-ple(i,k,j))/grav
>         end do
>       endif
> !      if(i.eq.47.and.j.eq.5)then
> !        write(6,*)'precl',precl(i,j),precc(i,j)
> !        call flush(6)
> !        do k=k1,k2
> !        write(6,*)'pdog',i,k,j,pdog(i,k,j),ple(i,k+1,j),ple(i,k,j)
> !        end do
> !        !call flush(6)
> !      endif
> !      pdog(i,k1:k2,j) = (ple(i,k1+1:k2+1,j)-ple(i,k1:k2,j)) / grav
>     enddo
>    enddo
> 
>    do nv=1, num_chem
> !  Loop over spatial indices
> #ifdef WETDEPDIAG
>     var_rmvl=0.
> #endif
>     do j = j1, j2
>      nmask=0
>        do i=i1,i2
>          if(precl(i,j)+precc(i,j).gt.0.0)then
>            nmask=nmask+1
>          endif
>        end do
>      if(nmask==0)cycle
> !     do k=k1,k2
> !       do i=i1,i2
> !         t2d(i,k)=tmpu(i,k,j)
> !       end do
> !     end do
>      kbota=k1
>      ktopa=k2
>     do i = i1, i2
> 
> !    Check for total precipitation amount
> !    Assume no precip in column if precl+precc = 0
> !     if(present(precc))then
>        pac = precl(i,j) + precc(i,j)
>        pcv = precc(i,j)
> !     else
> !       pac=precl(i,j)
> !       pcv=0.0
> !     endif
>      if(pac .le. 0.) cycle
>      pls = precl(i,j)
> 
> !    Initialize the precipitation fields
>      qls(:)  = 0.
>      qcv(:)  = 0.
>      fd(:,:) = 0.
> 
> !    Find the highest model layer experiencing rainout.  Assumes no
> !    scavenging if T < 258 K
>      LH = 0
364c896
<      do k = k2, k1,-1 !lzhang
---
>      do k = ktop,kbot,kinc
371,372c903
<      !if(LH .lt. 1) goto 100
<      if(LH .gt. k2) goto 100 !lzhang
---
>      if(LH .lt. 1) cycle
377c908,911
<      do k = LH, k1, -1  !lzhang
---
> !     if(i.eq.47.and.j.eq.5)then
> !       write(6,*)'lh',lh,'kbot',kbot,'kinc',kinc
> !     endif
>      do k = LH, kbot,kinc
379a914,920
> !      if(i.eq.47.and.j.eq.5)then
> !        write(6,*)'qls',k,qls(k),qcv(k)
> !      endif
> !      if(dqcond(i,k,j)/=0.0)then
> !        write(200+iam,*)'nv',nv,'dqcond',i,j,k,-dqcond(i,k,j),'pac',pac,'rhoa',rhoa(i,k,j)
> !        write(200+iam,*)'T',k,t2d(i,k),'alph  point',chempointsoluablefull(nv),alphasoluable(i,k,chempointsoluablefull(nv))
> !      endif
380a922,924
> !     do k=k1,k2
> !     write(6,*)'LH ',LH,' kbot ',kbot,' kinc ',kinc
> !     call flush(6)
384c928
<      do k = LH, k1, -1  !lzhang
---
>      do k = LH, kbot,kinc
404a949,951
> #ifdef WETDEPDIAG
>         dval=DC(n)
> #endif
405a953,956
> #ifdef WETDEPDIAG
>         if (chem(i,k,j,nv) .lt. 1.0E-32) &
>           dval=dval-(1.0e-32-chem(i,k,j,nv))
> #endif
406a958,960
> #ifdef WETDEPDIAG
>           var_rmvl(i,k,j)=var_rmvl(i,k,j)+dval
> #endif
422c976
<       if(k .lt. LH .and. qls(k) .ge. 0.) then !lzhang
---
>       if(k /= LH .and. qls(k) .ge. 0.) then
424c978
<        if(qls(k) .lt. qls(k+1)) then  !lzhang
---
>        if(qls(k) .lt. qls(k-kinc)) then
428c982
<         do kk = k+1,LH  !lzhang
---
>         do kk = k-kinc,LH,-kinc
460a1015,1019
> #ifdef WETDEPDIAG
>          dval=DC(n)
>          if (chem(i,k,j,nv) .lt. 1.0E-32) &
>            dval=dval-(1.0e-32-chem(i,k,j,nv))
> #endif
463c1022,1025
<           var_rmv(i,j,nv) = var_rmv(i,j,nv)+DC(n)*pdog(i,k,j)/cdt !ug/m2/s
---
>           var_rmv(i,j,nv) = var_rmv(i,j,nv)+DC(n)*pdog(i,k,j)/cdt
> #ifdef WETDEPDIAG
>           var_rmvl(i,k,j)=var_rmvl(i,k,j)+dval
> #endif
467a1030
> ! new for 9.0 don't allow
475c1038
< 
---
> !      if(present(precc))then
503,504c1066
<       !if (k.gt.LH .and. Qcv(k).ge.0.) then
<       if (k.lt.LH .and. Qcv(k).ge.0.) then !lzhang
---
>       if (k/=LH .and. Qcv(k).ge.0.) then
506c1068
<        if (Qcv(k).lt.Qcv(k+1)) then !lzhang
---
>        if (Qcv(k).lt.Qcv(k-kinc)) then
510c1072
<         do kk = k+1, LH !lzhang
---
>         do kk = k-kinc, LH, -kinc
542a1105,1109
> #ifdef WETDEPDIAG
>          dval=dc(n)
>          if (chem(i,k,j,nv) .lt. 1.0E-32) &
>            dval=dval-(1.e-32-chem(i,k,j,nv))
> #endif
545c1112,1115
<           var_rmv(i,j,nv) = var_rmv(i,j,nv)+DC(n)*pdog(i,k,j)/cdt !ug/m2/s
---
>           var_rmv(i,j,nv) = var_rmv(i,j,nv)+DC(n)*pdog(i,k,j)/cdt
> #ifdef WETDEPDIAG
>           var_rmvl(i,k,j)=var_rmvl(i,k,j)+dval
> #endif
550a1121
> !      end if ! present precc
556,557c1127
<       !if(k .gt. LH) then
<       if(k .lt. LH) then !lzhang
---
>       if(k /= LH) then
559,560c1129
<         !Fd(k,n) = Fd(k,n) + Fd(k-1,n)
<         Fd(k,n) = Fd(k,n) + Fd(k+1,n)  !lzhang
---
>         Fd(k,n) = Fd(k,n) + Fd(k-kinc,n)
567c1136
<         if (-dqcond(i,k+1,j) .gt. 0.) then !lzhang
---
>         if (-dqcond(i,k-kinc,j) .gt. 0.) then
571c1140
<             /      ( dqcond(i,k+1,j) * pdog(i,k+1,j))  ) !lzhang
---
>             /      ( dqcond(i,k-kinc,j) * pdog(i,k-kinc,j))  )
576,577c1145
<            !DC(n) =  Fd(k-1,n) / pdog(i,k,j) * A
<            DC(n) =  Fd(k+1,n) / pdog(i,k,j) * A  !lzhang
---
>            DC(n) =  Fd(k-kinc,n) / pdog(i,k,j) * A
578a1147,1152
> #ifdef WETDEPDIAG
>            dval=-dc(n)
>            if(chem(i,k,j,nv)<1.e-32)then
>              dval=dval+(1.e-32-chem(i,k,j,nv))
>            endif
> #endif
581a1156,1158
> #ifdef WETDEPDIAG
>            var_rmvl(i,k,j)=var_rmvl(i,k,j)+dval
> #endif
590,591c1167,1170
<        !var_rmv(i,j,nv) = var_rmv(i,j,nv)+Fd(k2,n)/cdt !lzhang
<        var_rmv(i,j,nv) = var_rmv(i,j,nv)+Fd(k1,n)/cdt ! ug/m2/s
---
> !      if(i.eq.47.and.j.eq.5)then
> !        write(6,*)'var_rmv nv',nv,var_rmv(i,j,nv),kbot,Fd(kbot,n),cdt
> !      endif
>        var_rmv(i,j,nv) = var_rmv(i,j,nv)+Fd(kbot,n)/cdt
594d1172
<  100 continue
596a1175,1178
>    
> #ifdef WETDEPDIAG
>     call savewetdep(i1,i2,j1,j2,k1,k2,nv,num_chem,var_rmv,var_rmvl)
> #endif
603c1185
<    end subroutine WetRemovalGOCART
---
>    end subroutine new_WetRemovalGOCART
diff -rBbw chem/dust/dust_afwa_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/dust/dust_afwa_mod.F90
407c407
<   ! emit_vol=emit/den_dust(n) ! (m s^-1)
---
>    emit_vol=emit/den_dust(n) ! (m s^-1)
419c419
<         dsrc = emit*distr_dust(n)*dxy(j)*dt1  ! (kg)
---
>         dsrc = emit_vol*den_dust(n)*distr_dust(n)*dxy(j)*dt1  ! (kg)
424,425c424
<         !bems(i,j,n) = dsrc/(dxy(j)*dt1) ! diagnostic (kg/m2/s)
<         bems(i,j,n) = 1.e+9*dsrc/(dxy(j)*dt1) ! diagnostic (ug/m2/s)
---
>         bems(i,j,n) = dsrc/(dxy(j)*dt1) ! diagnostic (kg/m2/s)
diff -rBbw chem/dust/dust_fengsha_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/dust/dust_fengsha_mod.F90
65a66,69
>     integer iat,jat,mype
>     common /iatjat/iat,jat
>     common /at/mype
> 
80a85
>       jat=j
81a87
>          iat=i
326a334,336
>     integer iat,jat,mype
>     common/iatjat/iat,jat
>     common /at/mype
379a390,393
> !             if(u_ts0/=0.0)then
> !               write(6,*)'u_ts0',iat,jat,u_ts0
> !               call flush(6)
> !             endif
382a397,399
> !               if(u_ts0/=0.0)then
> !                 write(6,*)'grav',iat,jat,'u_ts',u_ts,R
> !               endif
384a402,404
> !               if(u_ts0/=0.0)then
> !                 write(6,*)'no grav',iat,jat,'u_ts',u_ts,R
> !               endif
445c465
<        !emit_vol=emit/den_dust(n) ! (m s^-1)
---
>        emit_vol=emit/den_dust(n) ! (m s^-1)
458c478
<              dsrc = emit*distr_dust(n)*dxy(j)*dt1  ! (kg)
---
>              dsrc = emit_vol*den_dust(n)*distr_dust(n)*dxy(j)*dt1  ! (kg)
464,465c484
<              !bems(i,j,n) = 1000.*dsrc/(dxy(j)*dt1) ! diagnostic (g/m2/s)
<              bems(i,j,n) = 1.e+9*dsrc/(dxy(j)*dt1) ! diagnostic (ug/m2/s) !lzhang
---
>              bems(i,j,n) = 1000.*dsrc/(dxy(j)*dt1) ! diagnostic (g/m2/s)
diff -rBbw chem/gocart/gocart_diag_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/gocart/gocart_diag_mod.F90
9d8
<                                p_seas_3,     &
53c52
<               coef = 1.e-9_CHEM_KIND_R8 * (pr(i,j,k)-pr(i,j,k+1)) / g  !kg/m2
---
>               coef = 1.e-6_CHEM_KIND_R8 * (pr(i,j,k)-pr(i,j,k+1)) / g
63,64c62
<               trcm(i,j,6) = trcm(i,j,6) + coef * (tr(i,j,k,nbegin + p_seas_1) + tr(i,j,k,nbegin + p_seas_2 ) &
<               + fseas2* tr(i,j,k,nbegin + p_seas_3))
---
>               trcm(i,j,6) = trcm(i,j,6) + coef * (tr(i,j,k,nbegin + p_seas_1) + fseas2 * tr(i,j,k,nbegin + p_seas_2))
82c80
<               coef = 1.e-9_CHEM_KIND_R8 * (pr(i,j,k)-pr(i,j,k+1)) / g !kg/m2
---
>               coef = 1.e-6_CHEM_KIND_R8 * (pr(i,j,k)-pr(i,j,k+1)) / g
117c115
<     real(CHEM_KIND_R4), parameter :: ugkg = 1.e-09_CHEM_KIND_R4 !lzhang
---
> 
132c130
<       w(:,:,m,ipos) = ugkg*v(:,:,n) !kg/m2/s
---
>       w(:,:,m,ipos) = v(:,:,n)
diff -rBbw chem/gocart/gocart_model_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/gocart/gocart_model_mod.F90
7a8
>   use chem_raqms_mod
105c106,109
< 
---
> !      write(6,*)'uthr',data%uthr(is:is+1,js:js+1)
> !      call flush(6)
> !      write(6,*)'call gocart_advance'
> !      flush(6)
202a207
>         chem_pass_state=>stateout
diff -rBbw chem/gocart/gocart_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/gocart/gocart_mod.F90
37a38
>   use chem_raqms_mod
360c361,403
<     real(CHEM_KIND_R4), parameter :: ugkg = 1.e-09_CHEM_KIND_R4 !lzhang
---
>     integer mype,iat,jat
>     common/at/mype
> !    common/ij/iat,jat
> !   begin ajl for flip
>     real(CHEM_KIND_R4), dimension(ims:ime, kms:kme, jms:jme) :: p8w_r
>     real(CHEM_KIND_R4), dimension(ims:ime, kms:kme, jms:jme) :: rho_phy_r
>     real(CHEM_KIND_R4), dimension(ims:ime, kms:kme, jms:jme) :: t_phy_r
>     real(CHEM_KIND_R4), dimension(ims:ime, kms:kme, jms:jme, 1:num_chem) :: chem_r
>     real(CHEM_KIND_R4), dimension(ims:ime, kms:kme, jms:jme) :: dqdti_r
>     integer kk
>     logical doflip,first,donewwetdepgocart
>     save doflip,first
>     data doflip/.true./,first/.true./,donewwetdepgocart/.false./
>     character *10 cenv
> !    write(6,*)'top gsdchem num_chem',num_chem,'mype',mype
> !    call flush(6)
>     if(first)then
>       cenv=' '
>       call getenv('FLIPWETDEP',cenv)
>       if(cenv=='NO')then
>         doflip=.false.
>         if(mype.eq.0.and.tile.eq.1)then
>           write(6,*)'skip FLIPWETDEP'
>         endif
>       else
>         if(mype.eq.0.and.tile.eq.1)then
>           write(6,*)'FLIPWETDEP'
>         endif
>       endif
>       first=.false.
>       cenv=' '
>       call getenv('NEWWETDEPGOCART',cenv)
>       if(cenv.eq.'YES')then
>         donewwetdepgocart=.true.
>         if(mype.eq.0.and.tile.eq.1)then
>           write(6,*)'NEWWETDEPGOCART'
>         endif
>       endif
>     endif
> 
> 
> 
> !   end ajl for flip
590c633
<         emis_seas(its:ite,1,jts:jte,1:num_emis_seas) !kg/m2/s
---
>         emis_seas(its:ite,1,jts:jte,1:num_emis_seas)
628c671
<       truf(:,:,1:num_emis_dust) = ugkg*emis_dust(its:ite,1,jts:jte,1:num_emis_dust) !kg/m2/s
---
>       truf(:,:,1:num_emis_dust) = emis_dust(its:ite,1,jts:jte,1:num_emis_dust)
630a674,680
> !     if(ids<=145.and.145<=ide.and.jds<=73.and.73<=jde)then
> !     write(300+mype,*)'ids',ids,ide,'ims',ims,ime,'its',its,ite
> !     write(300+mype,*)'kds',kds,kde,'kms',kms,kme,'kts',kts,kte
> !     write(300+mype,*)'jds',jds,jde,'jms',jms,jme,'jts',jts,jte
> !     write(300+mype,*)'shape z_at_w',shape(z_at_w),z_at_w(145,1:3,73)
> !     endif
>       
770c820
<          call wetdep_ls(dt,chem,rnav,moist,rho_phy,var_rmv,xlat, &
---
>          call wetdep_ls(dt,chem,rnav,moist,rho_phy,var_rmv,     &
775a826,868
>         if(doflip)then
>           do k=kts,kte+1
>             kk=kme-k+1
>             p8w_r(:,k,:)=p8w(:,kk,:)
>           end do
>           do k=kts,kte
>             kk=kme-k
>             t_phy_r(:,k,:)=t_phy(:,kk,:)
>             rho_phy_r(:,k,:)=rho_phy(:,kk,:)
>             chem_r(:,k,:,:)=chem(:,kk,:,:)
>             dqdti_r(:,k,:)=dqdti(:,kk,:)
>           end do
>           t_phy_r(:,kte+1,:)=t_phy_r(:,kte,:)
>           rho_phy_r(:,kte+1,:)=rho_phy_r(:,kte,:)
>           chem_r(:,kte+1,:,:)=chem_r(:,kte,:,:)
>           dqdti_r(:,kte+1,:)=dqdti_r(:,kte,:)
>           call WetRemovalGOCART(its,ite, jts,jte, kts,kte, 1,1, dt, &
> !                               num_chem,var_rmv,chem_r,p_phy_r,t_phy_r,  &
>                                num_chem,var_rmv,chem_r,p8w_r,t_phy_r,  &
>                                rho_phy_r,dqdti_r,rcav,rnav,            &
>                                ims,ime, jms,jme, kms,kme, localrc)
>            do k=kts,kte
>              kk=kme-k
>              chem(:,kk,:,:)=chem_r(:,k,:,:)
>            enddo
>          elseif(donewwetdepgocart)then
>            call new_WetRemovalGOCART(its,ite, jts,jte, kts,kte, 1,1, dt, &
> !                               num_chem,var_rmv,chem,p_phy,t_phy,  &
>                                num_chem,var_rmv,chem,p8w,t_phy,  &
> !                               rho_phy,dqdti,precc,precl,          &    
>                                rho_phy,dqdti,rcav,rnav,          & ! AJL
>                                ims,ime, jms,jme, kms,kme, localrc)
>          else
> !           if(mype.eq.0.and.tile.eq.1)then
>            !write(6,*)'kts',kts,kte,'kds',kds,kde,'kms',kms,kme
> !           call flush(6)
> !           do k=kts,kte
> !             write(6,*)'p',k,p_phy(its,k,jts),' T ',t_phy(its,k,jts),'chem',maxval(chem(:,k,:,10))
> !           end do 
> !           write(6,*)'old wetdep'
> !           endif
>            
>            
779a873,879
>          endif
> !         if(mype.eq.0.and.tile.eq.1)then
> !           do i=1,num_chem
> !             !write(6,*)'var_rmv',maxval(var_rmv(:,:,i)),minval(var_rmv(:,:,i))
> !             write(6,*)maxloc(var_rmv(:,:,i))
> !           end do
> !         endif
888a989,990
> !    write(6,*)'gsdchem num_chem',num_chem,'mype',mype
> !    call flush(6)
912,923c1015,1023
<     ! -- output anthropogenic emissions, kg/m2/s
<     trab(:,:,1) = ugkg*emis_ant(its:ite, kts, jts:jte, p_e_bc )
<     trab(:,:,2) = ugkg*emis_ant(its:ite, kts, jts:jte, p_e_oc )
<     trab(:,:,3) = ugkg*emis_ant(its:ite, kts, jts:jte, p_e_so2)
< 
<     ! -- output biomass burning emissions,kg/m2/s
<     trab(:,:,4) = ugkg*ebu_in(its:ite, jts:jte, p_ebu_in_bc )
<     trab(:,:,5) = ugkg*ebu_in(its:ite, jts:jte, p_ebu_in_oc )
<     trab(:,:,6) = ugkg*ebu_in(its:ite, jts:jte, p_ebu_in_so2)
< 
<     ! -- output aod !lzhang
<     trab(:,:,7) = aod2d(its:ite, jts:jte)
---
>     ! -- output anthropogenic emissions
>     trab(:,:,1) = emis_ant(its:ite, kts, jts:jte, p_e_bc )
>     trab(:,:,2) = emis_ant(its:ite, kts, jts:jte, p_e_oc )
>     trab(:,:,3) = emis_ant(its:ite, kts, jts:jte, p_e_so2)
> 
>     ! -- output biomass burning emissions
>     trab(:,:,4) = ebu_in(its:ite, jts:jte, p_ebu_in_bc )
>     trab(:,:,5) = ebu_in(its:ite, jts:jte, p_ebu_in_oc )
>     trab(:,:,6) = ebu_in(its:ite, jts:jte, p_ebu_in_so2)
diff -rBbw chem/gocart/gocart_prep_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/gocart/gocart_prep_mod.F90
205c205
<     real(CHEM_KIND_R4), parameter :: frac_so2_ant       = 1.0_CHEM_KIND_R4     ! antropogenic so2 fraction
---
>     real(CHEM_KIND_R4), parameter :: frac_so2_ant       = 0.5_CHEM_KIND_R4     ! antropogenic so2 fraction
207a208,209
>     integer mype
>     common/at/mype
314a317,321
> !    if(its<=145.and.145<=ite.and.jts<=73.and.73<=jte)then
> !    write(6,*)'its',its,ite,'jts',jts,jte,'kts',kts,kte
> !    write(6,*)'shape z_at_w',shape(z_at_w)
> !    write(6,*)'z_at_w',kts,minval(z_at_w(:,kts,:))
> !    endif
323a331,336
> !          if(i==145.and.j==73)then
> !    if(its<=145.and.145<=ite.and.jts<=73.and.73<=jte)then
> !            write(6,*)'ph3d',kp,ph3d(ip,jp,kp:kp+1),'g',g,'ip',ip,jp
> !            write(6,*)'dz',dz8w(i,k,j),k,'z_at_w',i,k,j,z_at_w(i,k:k+1,j)
> !          endif
> !          endif
326a340,343
> !    if(its<=145.and.145<=ite.and.jts<=73.and.73<=jte)then
> !    write(6,*)'z_at_w kts+1',minval(z_at_w(:,kts+1,:)),maxval(z_at_w(:,kts+1,:))
> !    write(6,*)'dz8w',minval(dz8w(:,kts,:)),maxval(dz8w(:,kts,:))
> !    endif
392,393c409
<           !emis_ant(i,k,j,p_e_oc)=emiss_ab(i,j,p_e_oc) + emiss_ab(i,j,p_e_pm_25)
<           emis_ant(i,k,j,p_e_oc)=emiss_ab(i,j,p_e_oc)
---
>           emis_ant(i,k,j,p_e_oc)=emiss_ab(i,j,p_e_oc) + emiss_ab(i,j,p_e_pm_25)
395d410
<           !emis_ant(i,k,j,p_e_sulf)=(emiss_ab(i,j,p_e_pm_25)-emiss_ab(i,j,p_e_bc)-emiss_ab(i,j,p_e_oc))
463,464c478
<               !ebu_in(i,j,p_ebu_in_oc)   = frpc * (emiss_abu(i,j,p_e_pm_25) - emiss_abu(i,j,p_e_bc))
<               ebu_in(i,j,p_ebu_in_oc)   = frpc * emiss_abu(i,j,p_e_oc)
---
>               ebu_in(i,j,p_ebu_in_oc)   = frpc * (emiss_abu(i,j,p_e_pm_25) - emiss_abu(i,j,p_e_bc))
511a526,531
> !         if(i==145.and.j==73)then
> !    if(its<=145.and.145<=ite.and.jts<=73.and.73<=jte)then
> !           write(6,*)'p_phy',k,p_phy(i,k,j),'kkp',kkp,'kts',kts
> !           write(6,*)'t_phy',k,t_phy(i,k,j)
> !         endif
> !         endif
513a534,539
> !         if(i==145.and.j==73)then
> !    if(its<=145.and.145<=ite.and.jts<=73.and.73<=jte)then
>             !write(300+mype,*)'ws3d',ip,jp,kkp,ws3d(ip,jp,kkp),'rri',rri(i,k,j),'g',g,'k',k
> !            write(300+mype,*)'vvel',vvel(i,k,j)
> !         endif
> !         endif
771d796
<             !chem(i,k,j,p_sulf)=chem(i,k,j,p_sulf)+emis_ant(i,k,j,p_e_sulf)*factor/ppm2ugkg(p_sulf)
diff -rBbw chem/gocart/gocart_settling_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/gocart/gocart_settling_mod.F90
52d51
<   real(CHEM_KIND_R8), DIMENSION (ime,jme,kme,num_chem) :: chem_before
230c229
<             chem_before(i,j,k,nv) =  chem(i,k,j,nv)  
---
>             sedim(i,j,nv) = sedim(i,j,nv) + chem(i,k,j,nv)*p8w(i,k,j)/g
263,273d261
< 
<            kk = 0
<           do k = kts,kte
<              kk = kk+1
<              chem(i,k,j,p_dust_1)=dust(1,1,kk,1)*converi          ! dust for size bin 1 [ug/kg]
<              chem(i,k,j,p_dust_2)=dust(1,1,kk,2)*converi          ! ...
<              chem(i,k,j,p_dust_3)=dust(1,1,kk,3)*converi          ! ...
<              chem(i,k,j,p_dust_4)=dust(1,1,kk,4)*converi          ! ...
<              chem(i,k,j,p_dust_5)=dust(1,1,kk,5)*converi          ! dust for size bin 5 (dust_opt 3: for all size bins) [ug/kg]
<           enddo
< #if 0
290d277
< #endif
322,332d308
<           do k=kts,kte
<              kk=kk+1
<              chem(i,k,j,p_seas_1)=sea_salt(1,1,kk,1)*converi
<              chem(i,k,j,p_seas_2)=sea_salt(1,1,kk,2)*converi
<              chem(i,k,j,p_seas_3)=sea_salt(1,1,kk,3)*converi
<              chem(i,k,j,p_seas_4)=sea_salt(1,1,kk,4)*converi
<              chem(i,k,j,p_seas_5)=sea_salt(1,1,kk,5)*converi
<           enddo
< 
< #if 0          
<           kk=0
348,349d323
< #endif
< 
354c328
<               sedim(i,j,nv) = sedim(i,j,nv)+(chem_before(i,j,k,nv) - chem(i,k,j,nv))*p8w(i,k,j)/g
---
>               sedim(i,j,nv) = sedim(i,j,nv) - chem(i,k,j,nv)*p8w(i,k,j)/g
356c330
<             sedim(i,j,nv) = sedim(i,j,nv) / dt  !ug/m2/s
---
>             sedim(i,j,nv) = sedim(i,j,nv) / dt
516a491,500
>                  ! Update mixing ratio
>                  !! Order of delz is top->sfc
>                  !IF (l == lmx) THEN
>                  !   tc(i,j,l,k) = tc(i,j,l,k) / &
>                  !        (1.0 + dt_settl(k)*vd_cor/delz(i,j,l2))
>                  !ELSE
>                  !   tc(i,j,l,k) = 1.0/(1.0+dt_settl(k)*vd_cor/delz(i,j,l2))&
>                  !        *(tc(i,j,l,k) + dt_settl(k)*vd_cor /delz(i,j,l2-1) &
>                  !        * tc(i,j,l+1,k))
>                  !END IF
diff -rBbw chem/opt/opt_averaging_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/opt/opt_averaging_mod.F90
58c58
<               p_vash_1,p_vash_4,p_p10,p_dust_5,p_seas_5
---
>               p_vash_1,p_vash_4,p_p10
417c417
<    USE chem_const_mod, only: oc_mfac,nh4_mfac,mwdry
---
>    USE chem_const_mod, only: oc_mfac,nh4_mfac
492,494c492,493
<    !lzhang  REAL, PARAMETER :: FRAC2Aitken=0.25   ! Fraction of modal mass in Aitken mode - applied globally to each species
<    REAL, PARAMETER :: FRAC2Aitken=0.1   ! Fraction of modal mass in Aitken mode - applied globally to each species
<    real, DIMENSION (ndust), PARAMETER ::distr_dust=(/1.074D-1,1.012D-1,2.078D-1,4.817D-1,1.019D-1/) !lzhang
---
>    REAL, PARAMETER :: FRAC2Aitken=0.25   ! Fraction of modal mass in Aitken mode - applied globally to each species
> 
523,524c522
<       !lzhang  dhi_um=10.0
<       dhi_um=20.0 !lzhang
---
>       dhi_um=10.0
557c555
<        !dlogoc=0.46*2.E-6 ! Begin lower dust bin, makes upper limit diam 20 micron diameter
---
>        dlogoc=0.46*2.E-6 ! Begin lower dust bin, makes upper limit diam 20 micron diameter
559,561c557
<         !dhigoc = 4.*reff_dust(m)-dlogoc ! hi diameter limit (m)
<         dlogoc = 2 * lo_dust(m)  ! low diameter limit (m)
<         dhigoc = 2 * up_dust(m)  ! hi diameter limit (m)
---
>         dhigoc = 4.*reff_dust(m)-dlogoc ! hi diameter limit (m)
570,579c565,569
< !lzhang
<        !if(m.le.2.and.n.eq.2)dustfrc_goc8bin(m,n)=dustfrc_goc8bin(m,n)+.135*.059
<        !if(m.le.2.and.n.eq.3)dustfrc_goc8bin(m,n)=dustfrc_goc8bin(m,n)+.135*.167
<        !if(m.le.2.and.n.eq.4)dustfrc_goc8bin(m,n)=dustfrc_goc8bin(m,n)+.135*.315
<        !if(m.le.2.and.n.eq.5)dustfrc_goc8bin(m,n)=dustfrc_goc8bin(m,n)+.135*.458
<        
<        if(m.le.2.and.n.eq.2)dustfrc_goc8bin(m,n)=dustfrc_goc8bin(m,n)+(distr_dust(1)+distr_dust(2))*.059
<        if(m.le.2.and.n.eq.3)dustfrc_goc8bin(m,n)=dustfrc_goc8bin(m,n)+(distr_dust(1)+distr_dust(2))*.167
<        if(m.le.2.and.n.eq.4)dustfrc_goc8bin(m,n)=dustfrc_goc8bin(m,n)+(distr_dust(1)+distr_dust(2))*.315
<        if(m.le.2.and.n.eq.5)dustfrc_goc8bin(m,n)=dustfrc_goc8bin(m,n)+(distr_dust(1)+distr_dust(2))*.458
---
>        if(m.le.2.and.n.eq.2)dustfrc_goc8bin(m,n)=dustfrc_goc8bin(m,n)+.135*.059
>        if(m.le.2.and.n.eq.3)dustfrc_goc8bin(m,n)=dustfrc_goc8bin(m,n)+.135*.167
>        if(m.le.2.and.n.eq.4)dustfrc_goc8bin(m,n)=dustfrc_goc8bin(m,n)+.135*.315
>        if(m.le.2.and.n.eq.5)dustfrc_goc8bin(m,n)=dustfrc_goc8bin(m,n)+.135*.458
> 
765,766c755
<         !lzhang conv1sulf = (1.0/alt(i,k,j)) * 1.0e-9 * 96./28.97
<         conv1sulf = (1.0/alt(i,k,j)) * 1.0e-9 * mw_so4_aer / mwdry * 2.5 
---
>         conv1sulf = (1.0/alt(i,k,j)) * 1.0e-9 * 96./28.97
770c759
<         mass_oinj = (1.-FRAC2Aitken)*(chem(i,k,j,p_p25)+chem(i,k,j,p_p10))*conv1a
---
>         mass_oinj = (1.-FRAC2Aitken)*chem(i,k,j,p_p25)*conv1a
772,774c761
<         !mass_nh4j= (1.-FRAC2Aitken)*chem(i,k,j,p_sulf)*conv1sulf*(nh4_mfac-1.)
<         mass_nh4j= (1.-FRAC2Aitken)*chem(i,k,j,p_sulf)*conv1sulf*0.6 !lzhang
<         mass_no3j= (1.-FRAC2Aitken)*chem(i,k,j,p_sulf)*conv1sulf*0.76 !lzhang
---
>         mass_nh4j= (1.-FRAC2Aitken)*chem(i,k,j,p_sulf)*conv1sulf*(nh4_mfac-1.)
785c772
<         mass_oini = FRAC2Aitken*(chem(i,k,j,p_p25)+chem(i,k,j,p_p10))*conv1a
---
>         mass_oini = FRAC2Aitken*chem(i,k,j,p_p25)*conv1a
787,789c774
<         !lzhang mass_nh4i= FRAC2Aitken*chem(i,k,j,p_sulf)*conv1sulf*(nh4_mfac-1.)
<         mass_nh4i= FRAC2Aitken*chem(i,k,j,p_sulf)*conv1sulf*0.6 !lzhang
<         mass_no3i= FRAC2Aitken*chem(i,k,j,p_sulf)*conv1sulf*0.76 !lzhang
---
>         mass_nh4i= FRAC2Aitken*chem(i,k,j,p_sulf)*conv1sulf*(nh4_mfac-1.)
848,849c833
<        !lzhang do m =p_seas_1,  p_seas_4 ! loop over sea salt size bins less than 10 um diam
<        do m =p_seas_1,  p_seas_5 ! loop over sea salt size bins less than 10 um diam
---
>        do m =p_seas_1,  p_seas_4 ! loop over sea salt size bins less than 10 um diam
861,862c845
<        !lzhang  do m =p_dust_1,  pdust ! loop over dust size bins less than 10 um diam
<        do m =p_dust_1,  p_dust_5 ! loop over dust size bins less than 20 um diam
---
>        do m =p_dust_1,  pdust ! loop over dust size bins less than 10 um diam
864c847
<         mass_soil=mass_soil+dustfrc_goc8bin(n,isize)*chem(i,k,j,m)*1.5
---
>         mass_soil=mass_soil+dustfrc_goc8bin(n,isize)*chem(i,k,j,m)
diff -rBbw chem/opt/opt_gocart_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/opt/opt_gocart_mod.F90
33,36c33
<   !real,parameter :: frac(4)=(/ 0.01053,0.08421,0.25263,0.65263 /) !fraction for fine dust 
<   !real,parameter :: frac(4)=(/0.0054,0.0257,0.1923,0.7766/) !fraction for fine dust !lzhang Kok
<   real,parameter :: frac(4)=(/0.06,0.12,0.24,0.58/) !fraction for fine dust !lzhang GEOS-Chem
<   !real,parameter :: frac(4)=(/0.0070,0.0332,0.2487,0.7111/) !fraction for fine dust !lzhang IMP
---
>   real,parameter :: frac(4)=(/ 0.01053,0.08421,0.25263,0.65263 /) !fraction for fine dust
54,55c51,52
< !  5 = SS1      !sea-salt accumulation mode !SS1+SS2
< !  6 = SS2+SS3+SS4 !sea-salt coarse mode    !SS3+SS4+SS5
---
> !  5 = SS1      !sea-salt accumulation mode
> !  6 = SS2+SS3+SS4 !sea-salt coarse mode
8565c8562
<    USE chem_const_mod, only: oc_mfac,nh4_mfac,mw_so4_aer,mwdry !lzhang
---
>    USE chem_const_mod, only: oc_mfac,nh4_mfac
8593,8594c8590,8591
< !  5 = SS1+SS2  ! sea-salt accumulation mode !lzhang
< !  6 = SS3+SS4+SS5 !sea-salt coarse mode !lzhang
---
> !  5 = SS1      ! sea-salt accumulation mode
> !  6 = SS2+SS3+SS4 !sea-salt coarse mode
8623c8620
<  real :: conv1a,conv1sulf
---
>  real :: conv1a
8639,8661c8636,8646
< !lzhang  convert ppmv sulfate (and coincidentally MSA) to g / m3
<         conv1sulf = (1.0/alt(i,k,j)) * 1.0e-3 * mw_so4_aer / mwdry
< 
<    !aero(k,1)=chem(i,k,j,p_sulf)*conv1a*1.e3*nh4_mfac !lzhang
<    !aero(k,1)=chem(i,k,j,p_sulf)*conv1sulf*nh4_mfac
<    !aero(k,1)=chem(i,k,j,p_sulf)*conv1sulf*1.6
<    aero(k,1)=(chem(i,k,j,p_sulf)+chem(i,k,j,p_msa))*conv1sulf*1.8
<    aero(k,2)=(chem(i,k,j,p_bc1)+chem(i,k,j,p_bc2))*conv1a*1.0
<    aero(k,3)=(chem(i,k,j,p_oc1))*conv1a*1.4
<    aero(k,4)=(chem(i,k,j,p_oc2))*conv1a*1.4
<    !aero(k,5)=(chem(i,k,j,p_seas_1)+chem(i,k,j,p_seas_2))*conv1a !lzhang
<    !aero(k,6)=(chem(i,k,j,p_seas_3)+chem(i,k,j,p_seas_4)+chem(i,k,j,p_seas_5))*conv1a !lzhang
<    aero(k,5)=(chem(i,k,j,p_seas_1)+chem(i,k,j,p_seas_2))*conv1a*2.5 !lzhang
<    aero(k,6)=(chem(i,k,j,p_seas_3)+chem(i,k,j,p_seas_4)+chem(i,k,j,p_seas_5))*conv1a*2.5 !lzhang
<    aero(k,7)=(chem(i,k,j,p_dust_1))*conv1a*frac(1)*1.6
<    aero(k,8)=(chem(i,k,j,p_dust_1))*conv1a*frac(2)*1.6
<    aero(k,9)=(chem(i,k,j,p_dust_1))*conv1a*frac(3)*1.6
<    aero(k,10)=(chem(i,k,j,p_dust_1))*conv1a*frac(4)*1.6
<    !aero(k,11)=(chem(i,k,j,p_dust_2))*conv1a*3.
<    aero(k,11)=(chem(i,k,j,p_dust_2)+chem(i,k,j,p_dust_3)+chem(i,k,j,p_dust_4)+chem(i,k,j,p_dust_5))*conv1a*1.6
<    !aero(k,12)=(chem(i,k,j,p_dust_3))*conv1a*3.  !lzhang
<    !aero(k,13)=(chem(i,k,j,p_dust_4))*conv1a*3. !lzhang
<    !aero(k,14)=(chem(i,k,j,p_dust_5))*conv1a*3. !lzhang
---
>    aero(k,1)=chem(i,k,j,p_sulf)*conv1a*1.e3*nh4_mfac
>    aero(k,2)=(chem(i,k,j,p_bc1)+chem(i,k,j,p_bc2))*conv1a
>    aero(k,3)=(chem(i,k,j,p_oc1))*conv1a*oc_mfac
>    aero(k,4)=(chem(i,k,j,p_oc2))*conv1a*oc_mfac
>    aero(k,5)=(chem(i,k,j,p_seas_2))*conv1a
>    aero(k,6)=(chem(i,k,j,p_seas_3))*conv1a
>    aero(k,7)=(chem(i,k,j,p_dust_1))*conv1a*frac(1)
>    aero(k,8)=(chem(i,k,j,p_dust_1))*conv1a*frac(2)
>    aero(k,9)=(chem(i,k,j,p_dust_1))*conv1a*frac(3)
>    aero(k,10)=(chem(i,k,j,p_dust_1))*conv1a*frac(4)
>    aero(k,11)=(chem(i,k,j,p_dust_2))*conv1a
8684,8685c8669
<                !if(rhi == 99) then
<                if(rhi == 99.or.tgmx>6) then
---
>                if(rhi == 99) then
8691d8674
<                   if (tgmx<=6)  then
8696d8678
<                   endif
diff -rBbw chem/plume/plume_rise_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/plume/plume_rise_mod.F90
5a6
>   use chem_const_mod, only : mw_bc,mw_oc,avgro
77a79,84
> !      real,dimension(ims:ime,jms:jme) :: colemisbc,colemisoc
> 
>       integer mype
>       common/at/mype
>       integer iat,jat
>       common/ij/iat,jat
80a88,89
> !      colemisbc=0.0
> !      colemisoc=0.0
231a241,255
> !              if(i==ims.and.j==jms)then
> !             if(i==145.and.j==73)then
> !              if(k==1)then
> !              write(300+mype,*)'i',i,j
> !              endif
> !              write(300+mype,*)k,'P',p_phy(i,k,j),'cp',cp,'rcp',rcp
> !              write(300+mype,*)k,'T',t_phy(i,k,j),'rd',r_d
> !              write(300+mype,*)k,'u',u_in(k),v_in(k),'w',w_in(k),'qv',qv_in(k)
> !              write(300+mype,*)k,'z_at_w',z_at_w(i,k,j),'rho',rho_phyin(k)
> !              write(300+mype,*)k,'pi',pi_in(k),'z_lev',z_lev(k)
> !              write(300+mype,*)k,'theta',theta_in(k)
> !              write(300+mype,*)k,'zmid',zmid(k)
> !             endif
> !              write(6,*)k,'p',p_phy(i,k,j),'zatw',z_at_w(i,k,j)
> !              call flush(6)
241a266,270
>             iat=i
>             jat=j
> !            write(300+mype,*)'firesize',firesize,'mean_fct',mean_fct
> !            write(300+mype,*)'plume_frp',plume_frp(i,j,:),plumerise_flag
> !           ajl Kg/m2 in Kg/m3 out
247c276
< 
---
> !            write(300+mype,*)'num_ebu',num_ebu
248a278
> !             convert back to Kg/m2 in a layer
251a282,297
>           
> !             if((nv==1.or.nv==2).and.ebu(i,kts,j,nv)/=0.0)then
> !               do k=kts,kte
> !                 if(ebu(i,k,j,nv)/=0.0)then
> !                   if(nv==1)then
> !                     colemisbc(i,j)=colemisbc(i,j)+ebu(i,k,j,nv)
> !                   else
> !                     colemisoc(i,j)=colemisoc(i,j)+ebu(i,k,j,nv)
> !                   endif
> !                   write(300+mype,*)'ebu 1 ',i,j,'k',k,ebu(i,k,j,nv),'dz',z_at_w(i,k+1,j)-z_at_w(i,k,j)
> !                   if(k/=kts)then
> !                   !write(300+mype,'("ratio",3i3,f10.6)')i,j,k,ebu(i,k,j,nv)/ebu(i,1,j,nv)
> !                   endif
> !                 endif
> !               end do
> !             endif
321a368,370
> !          write(6,*)'colemisbc',maxval(colemisbc),'oc',maxval(colemisoc)
>           !write(300+mype,*)'gsdchem colemisbc',maxval(colemisbc),'oc',maxval(colemisoc),' *10**-9'
> !          write(300+mype,*)'gsdchem colemisbc mol/cm2 ',maxval(colemisbc)*.1*1.e-9*avgro/mw_bc,'oc',maxval(colemisoc)*.1*1.e-9*avgro/mw_oc
diff -rBbw chem/plume/plume_scalar_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/plume/plume_scalar_mod.F90
45a46,49
>   integer mype
>   common/at/mype
>   integer iat,jat
>   common/ij/iat,jat
161a166
> !          write(300+mype,*)'imm',imm,'burn',burnt_area,'frp',frp,'iveg',iveg_ag
186a192,194
> !        write(300+mype,*)iat,jat,'k2',k2,'k1',k1,'dzi',dzi,zzcon(k2+1),zzcon(k1)
> !        write(300+mype,*)'ztopmax',ztopmax
> !        call flush(300+mype)
438a447,449
> integer iat,jat,mype
> common/ij/iat,jat
> common/at/mype
557a569
diff -rBbw chem/seas/seas_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/seas/seas_mod.F90
226c226
<                   ! for output diagnostics kg/m2/s
---
>                   ! for output diagnostics
diff -rBbw chem/shr/chem_config_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/shr/chem_config_mod.F90
98c98,99
<     logical :: readrestart        = .false.
---
> !    logical :: readrestart        = .false.
>     logical :: readrestart        = .true. ! AJL
384a386,387
>       write(6,*)'iostat',iostat
>       call flush(6)
385a389
>       call flush(6)
diff -rBbw chem/shr/chem_const_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/shr/chem_const_mod.F90
58a59,63
> ! ajl add
>  real,    parameter :: mw_CO=28.01
>  real,    parameter :: mw_BC=12.01
>  real,    parameter :: mw_OC=16.80
>  real,    parameter :: avgro=6.022E23
diff -rBbw chem/shr/chem_iodata_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/shr/chem_iodata_mod.F90
513c513
<           path=trim(config % fireemi_inname), de=de, rc=localrc)
---
>           path=trim(config % fireemi_inname), de=de, varname='ebu_bc',rc=localrc)
520c520
<           path=trim(config % fireemi_inname), de=de, rc=localrc)
---
>           path=trim(config % fireemi_inname), de=de, varname='ebu_oc',rc=localrc)
527c527
<           path=trim(config % fireemi_inname), de=de, rc=localrc)
---
>           path=trim(config % fireemi_inname), de=de, varname='ebu_pm25',rc=localrc)
534c534
<           path=trim(config % fireemi_inname), de=de, rc=localrc)
---
>           path=trim(config % fireemi_inname), de=de, varname='ebu_so2',rc=localrc)
554c554
<             if (config % plumerisefire_frq > 0) then
---
> !            write(6,*)'path',trim(config % fireemi_inname)
556c556,557
<               path=trim(config % fireemi_inname), de=de, rc=localrc)
---
>               path=trim(config % fireemi_inname), de=de, varname='plumefrp',rc=localrc)
> !            write(6,*)'plimefrp',shape(data%plume),'max',maxval(data%plume),minval(data%plume)
560d560
<             endif
diff -rBbw chem/shr/chem_io_mod.F90 /home/lenzen/FV3GFS-GSDCHEM.0.9.0.CHEMGSI/EMC_FV3GFS-GSDCHEM/GSDCHEM/src/chem/shr/chem_io_mod.F90
136c136
<   subroutine chem_io_file_name(fullname, filename, tile, pathname)
---
>   subroutine chem_io_file_name(fullname, filename, tile, pathname,doread)
140a141
>     logical, optional,intent(in)            :: doread
143c144
<     integer :: lstr
---
>     integer :: lstr,lstr2
144a146,147
>     logical exist
> 
153a157,158
>       elseif(filename(lstr-2:lstr) == '.nc')then
>          write(fname,'(a,".tile",i0,".nc")')filename(1:lstr-3),tile
163a169,176
> !        write(6,*)'pathname',trim(pathname)
> !        write(6,*)'lstr',lstr
> !        write(6,*)'len',len(fullname)
> !        call flush(6)
> !        write(6,*)'fname',trim(fname)
> !        call flush(6)
> !        write(6,*)'lstr',pathname(lstr:lstr)
> !        call flush(6)
164a178,182
> !          write(6,*)'176'
> !          call flush(6)
> !          write(6,*)'lenpathname',len_trim(pathname)
> !          write(6,*)'lenfname',len_trim(fname)
> !          call flush(6)
165a184,185
> !          write(6,*)'fullname',len_trim(fullname),trim(fullname)
> !          call flush(6)
166a187,188
> !          write(6,*)'180'
> !          call flush(6)
175a198,216
>     if(present(doread))then
>       inquire(file=fullname,exist=exist)
>       if(exist)return
> !     if not there see if netcdf file is    
>       lstr2=len_trim(fullname)
>       if (fullname(lstr2-3:lstr2) == '.dat')then
>         fullname(lstr2-3:lstr2)='.nc '
>         inquire(file=fullname,exist=exist)
> !       write(6,*)'inquire 2 ',exist,'fullname',trim(fullname)
>         if(exist)return
>         write(6,*)'gsdchemneither .dat nor .nc are there',fullname,'fname',fname
>         call killit('neither')
>       elseif(fullname(lstr2-2:lstr2)=='.nc')then
>         write(6,*)'.nc not there',fullname
>         call killit('.nc')
>       endif
>     endif
>     return
> 
335c376
<   subroutine chem_io_read_2DR4(filename, farray, path, recrange, recsize, recstride, de, rc)
---
>   subroutine chem_io_read_2DR4(filename, farray, path, recrange, recsize, recstride, de, varname, rc)
342a384
>     character(len=*), optional, intent(in)  :: varname
353a396,397
>     logical :: doread=.true.
>     integer lenstr,bsiz1d(1)
371a416
>     bsiz1d(1)=bsize(1)*bsize(2)
376a422
>     allocate(buf2d(its:ite,jts:jte), stat=localrc)
380,381c426,438
<       call chem_io_file_name(datafile, filename, tile, pathname=path)
< 
---
>       call chem_io_file_name(datafile, filename, tile, pathname=path,doread=doread)
>       lenstr=len_trim(datafile)
> !      write(6,*)'lenstr',lenstr,'datafile',trim(datafile)
> !      call flush(6)
>       if(datafile(lenstr-2:lenstr)=='.nc')then
>         if(present(varname))then
>           call chem_io_file_read_2d_nc(datafile, buf2d, recrange=recrange, &
>           recsize=recsize, recstride=recstride, varname=varname,rc=localrc)
>           buffer=reshape(buf2d,bsiz1d)
>         else 
>           write(6,*)'netcdf file without varname',trim(filename)
>         endif
>       else 
383a441
>       endif
394d451
<     allocate(buf2d(its:ite,jts:jte), stat=localrc)
411c468
<   subroutine chem_io_read_3DR4(filename, farray, path, recrange, recsize, recstride, de, rc)
---
>   subroutine chem_io_read_3DR4(filename, farray, path, recrange, recsize, recstride, de, varname, rc)
418a476
>     character(len=*), optional, intent(in)  :: varname
429a488,489
>     integer bsiz1d(1),lenstr
>     logical :: doread=.true.
442a503
>     bsiz1d=bsize(1)*bsize(2)*bsize(3)
453a515
>     allocate(buf3d(its:ite,jts:jte,bsize(3)), stat=localrc)
456,457c518,536
< 
<       call chem_io_file_name(datafile, filename, tile, pathname=path)
---
> !      write(6,*)'len datafile',len(datafile)
> !      call flush(6)
> !      write(6,*)'len filename',len_trim(filename)
> !      write(6,*)'len path',len_trim(path)
> !      call flush(6)
> 
>       call chem_io_file_name(datafile, filename, tile, pathname=path,doread=doread)
>       lenstr=len_trim(datafile)
> !      write(6,*)'lenstr3d',lenstr,'datafile',trim(datafile)
> !      call flush(6)
>       if(datafile(lenstr-2:lenstr)=='.nc')then
>         if(present(varname))then
>           call chem_io_file_read_3d_nc(datafile, buf3d, recrange=recrange, &
>           recsize=recsize, recstride=recstride, varname=varname,rc=localrc)
>           buffer=reshape(buf3d,bsiz1d)
>         else
>           write(6,*)'netcdf file without varname',trim(filename)
>         endif
>       else
460a540
>       endif
471d550
<     allocate(buf3d(its:ite,jts:jte,bsize(3)), stat=localrc)
1047a1127,1721
> ! add for netcdf files ajl
> 
>   subroutine chem_io_file_read_2d_nc(datafile, buffer, recrange, recsize, recstride, varname,rc)
>     use chem_comm_mod, only : chem_comm_get
>     use netcdf
>     character(len=*),   intent(in)  :: datafile
>     real(CHEM_KIND_R4), intent(out) :: buffer(:,:)
>     integer, optional,  intent(in)  :: recrange(2)
>     integer, optional,  intent(in)  :: recsize
>     integer, optional,  intent(in)  :: recstride
>     character(len=*), optional,  intent(in)  :: varname
>     character*120 namevar
>     integer, optional,  intent(out) :: rc
>      
> 
>     ! -- local variables
>     integer :: localrc
>     integer :: irec, is, ie,i
>     integer :: rcount, rsize, rstride
>     integer :: rrange(2)
>     integer :: nc,nr
>     integer :: mype
>     integer :: ncid ! ncid for netcdf file
>     integer :: ierr ! netcdf error code
>     integer :: varid ! netcdf varid
>     if(.not.present(varname))then
>       rc=1
>       write(6,*)'varname must be present for reading netcdf file input'
>       call flush(6)
>       return
>     endif
> !    write(6,*)'read_2d_nc var',trim(varname)
> !    call flush(6)
>     call chem_comm_get(localpe=mype)
> !    write(6,*)'chem_io_file_read_2d_nc mype',mype,shape(buffer)
> !    call flush(6)
> 
>     ! -- begin
>     if (present(rc)) rc = CHEM_RC_SUCCESS
> !    return ! for now
> 
>     buffer = 0._CHEM_KIND_R4
> 
>     if (present(recrange)) then
>       rrange = recrange
>     else
>       rrange = 1
>     end if
>     rcount = rrange(2) - rrange(1) + 1
> 
>     if (present(recsize)) then
>       rsize = recsize
>     else
>       rsize = size(buffer) / rcount
>     end if
> 
>     if (present(recstride)) then
>       rstride = recstride
>     else
>       rstride = rsize
>     end if
> !    write(6,*)'sizebuffer',size(buffer),'rcount',rcount,'rsize',rsize,'rstride',rstride
> !    write(70+mype,*)'sizebuffer',size(buffer),'rcount',rcount,'rsize',rsize,'rstride',rstride
> !    call flush(70+mype)
> !    write(6,*)'prod ',rcount * max(rsize, rstride)
> !    call flush(6)
> 
>     if (chem_rc_test((size(buffer) < rcount * max(rsize, rstride)), &
>         msg="insufficient buffer size", &
>         file=__FILE__, line=__LINE__, rc=rc)) return
> 
>     ! -- open file
> !    write(70+mype,*)'open',trim(datafile)
> !    call flush(70+mype)
>     ierr=nf90_open(trim(datafile),0,ncid)
>     if (ierr /= nf90_noerr)then
>        write(6,*)'error open ',trim(datafile)
>        call flush(6)
>        rc=1
>        return
>     else
> !      if(mype.eq.0)then
> !        write(6,*)'open 2d nc ',trim(datafile)
> !        call flush(6)
> !      endif
>     endif
>     ierr=nf90_inq_varid(ncid,trim(varname),varid)
>     if (ierr /= nf90_noerr)then
>       write(6,*)'error getting varid for ',trim(varname),' file ',trim(datafile)
>       write(6,*)trim(nf90_strerror(ierr))
>       call flush(6)
>       do i=1,3
>         ierr=nf90_inquire_variable(ncid,i,name=namevar)
>         write(6,*)'namevar',i,trim(namevar)
>         call flush(6)
>       end do
>       rc=1
>       return
> !    else
> !      write(6,*)'read id ',trim(varname),varid
> !      call flush(6)
>     endif
>     ierr=nf90_get_var(ncid,varid,buffer)
>     if (ierr /= nf90_noerr)then
>       write(6,*)'error getting var size buffer',shape(buffer),'var',trim(varname),'file',trim(datafile)
>       write(6,*)trim(nf90_strerror(ierr))
>       call flush(6)
>       rc=1
>       return
>     else
> !      if(mype.eq.0)then
> !        write(6,*)'read var',maxval(buffer),minval(buffer)
> !        call flush(6)
> !      endif
>     endif
> 
> 
>     ! -- close file
>      ierr=nf90_close(ncid)
> 
>   end subroutine chem_io_file_read_2d_nc
>   subroutine chem_io_file_read_3d_nc(datafile, buffer, recrange, recsize, recstride, varname,rc)
>     use chem_comm_mod, only : chem_comm_get
>     use netcdf
>     character(len=*),   intent(in)  :: datafile
>     real(CHEM_KIND_R4), intent(out) :: buffer(:,:,:)
>     integer, optional,  intent(in)  :: recrange(2)
>     integer, optional,  intent(in)  :: recsize
>     integer, optional,  intent(in)  :: recstride
>     character(len=*), optional,  intent(in)  :: varname
>     integer, optional,  intent(out) :: rc
> 
>     ! -- local variables
>     integer :: localrc
>     integer :: irec, is, ie
>     integer :: rcount, rsize, rstride
>     integer :: rrange(2)
>     integer :: nc,nr
>     integer :: mype
>     integer :: ncid ! ncid for netcdf file
>     integer :: ierr ! netcdf error code
>     integer :: varid ! netcdf varid
>     if(.not.present(varname))then
>       rc=1
>       write(6,*)'varname must be present for reading netcdf file input'
>       call flush(6)
>       return
>     endif
>     call chem_comm_get(localpe=mype)
> 
>     ! -- begin
>     if (present(rc)) rc = CHEM_RC_SUCCESS
> 
>     buffer = 0._CHEM_KIND_R4
> 
>     if (present(recrange)) then
>       rrange = recrange
>     else
>       rrange = 1
>     end if
>     rcount = rrange(2) - rrange(1) + 1
> 
>     if (present(recsize)) then
>       rsize = recsize
>     else
>       rsize = size(buffer) / rcount
>     end if
> 
>     if (present(recstride)) then
>       rstride = recstride
>     else
>       rstride = rsize
>     end if
> 
>     if (chem_rc_test((size(buffer) < rcount * max(rsize, rstride)), &
>         msg="insufficient buffer size", &
>         file=__FILE__, line=__LINE__, rc=rc)) return
> 
>     ! -- open file
>     ierr=nf90_open(trim(datafile),0,ncid)
>     if (ierr /= nf90_noerr)then
>        write(6,*)'error open ',trim(datafile)
>        call flush(6)
>        rc=1
>        return
>     endif
>     ierr=nf90_inq_varid(ncid,trim(varname),varid)
>     if (ierr /= nf90_noerr)then
>       write(6,*)'error getting varid for ',trim(varname),' file ',trim(datafile)
>       write(6,*)trim(nf90_strerror(ierr))
>       rc=1
>       return
>     endif
>     ierr=nf90_get_var(ncid,varid,buffer)
>     if (ierr /= nf90_noerr)then
>       write(6,*)'error getting var size buffer',shape(buffer),'var',trim(varname),'file',trim(datafile)
>       write(6,*)trim(nf90_strerror(ierr))
>       call flush(6)
>       rc=1
>       return
>     endif
>      ierr=nf90_close(ncid)
> 
>   end subroutine chem_io_file_read_3d_nc
> 
> 
>   subroutine chem_io_writenc_2DR4(filename, farray, path, pos, de, time,varname,units,rc)
>     use netcdf
>     use chem_comm_mod, only : chem_comm_get
> !    use raqmschem_pmgrid_mod, only : iam
>     character(len=*),           intent(in)  :: filename
>     real(CHEM_KIND_R4),         intent(in)  :: farray(:,:)
>     character(len=*), optional, intent(in)  :: path
>     character(len=*), optional, intent(in)  :: pos
>     integer,          optional, intent(in)  :: de
>     integer,          optional, intent(in)  :: time
>     character(len=*),optional,  intent(in)  :: varname
>     character(len=*),optional,  intent(in)  :: units
>     integer,          optional, intent(out) :: rc
> 
>     ! -- local variables
>     integer :: localrc
>     integer :: tile, tileComm
>     integer :: ids, ide, jds, jde, its, ite, jts, jte
>     logical :: localIOflag
>     character(len=CHEM_MAXSTR) :: datafile
>     real(CHEM_KIND_R4), dimension(:,:), allocatable, target :: buf2d, recvbuf
>     real(chem_kind_R8), pointer, dimension(:,: ) :: lat2dr8,lon2dr8
>     real(chem_kind_R4), pointer, dimension(:,: ) :: lat2d,lon2d,latbuf,lonbuf
>     integer ncid,ierr,lenf,mype
>     lenf=len_trim(filename)
> 
>     ! -- begin
>     if (present(rc)) rc = CHEM_RC_SUCCESS
>     call chem_comm_get(localpe=mype)
> 
>     call chem_model_get(de=de, tile=tile, tileComm=tileComm, &
>       localIOflag=localIOflag, rc=localrc)
>     if (chem_rc_check(localrc, file=__FILE__, line=__LINE__, rc=rc)) return
>     call chem_model_domain_get(de=de, ids=ids, ide=ide, jds=jds, jde=jde, &
>       its=its, ite=ite, jts=jts, jte=jte, lon=lon2dr8,lat=lat2dr8,rc=localrc)
>     if (chem_rc_check(localrc, file=__FILE__, line=__LINE__, rc=rc)) return
> 
>     ! -- check size consistency
>     if (chem_rc_test((size(farray) /= (ide-ids+1)*(jde-jds+1)), &
>       msg="size of input array inconsistent with domain decomposition", &
>       file=__FILE__, line=__LINE__, rc=rc)) return
> 
>     allocate(buf2d(its:ite,jts:jte), stat=localrc)
>     if (chem_rc_test((localrc /= 0), &
>       msg="Cannot allocate read buffer", &
>       file=__FILE__, line=__LINE__, rc=rc)) return
>     buf2d = 0._CHEM_KIND_R4
> 
>     buf2d(ids:ide, jds:jde) = farray
> 
>     allocate(recvbuf(its:ite,jts:jte), stat=localrc)
>     allocate(lonbuf(its:ite,jts:jte), stat=localrc)
>     allocate(latbuf(its:ite,jts:jte), stat=localrc)
>     allocate(lat2d(its:ite,jts:jte))
>     allocate(lon2d(its:ite,jts:jte))
>     lat2d=0.
>     lon2d=0.
>     lat2d(ids:ide,jds:jde)=lat2dr8
>     lon2d(ids:ide,jds:jde)=lon2dr8
>     if (chem_rc_test((localrc /= 0), &
>       msg="Cannot allocate read buffer", &
>       file=__FILE__, line=__LINE__, rc=rc)) return
> 
>     recvbuf = 0._CHEM_KIND_R4
>     latbuf=0._CHEM_KIND_R4
>     lonbuf=0._CHEM_KIND_R4
> 
>     call chem_comm_reduce(buf2d, recvbuf, CHEM_COMM_SUM, comm=tileComm, rc=localrc)
>     if (chem_rc_check(localrc, file=__FILE__, line=__LINE__, rc=rc)) return
>     call chem_comm_reduce(lat2d, latbuf, CHEM_COMM_SUM, comm=tileComm, rc=localrc)
>     if (chem_rc_check(localrc, file=__FILE__, line=__LINE__, rc=rc)) return
>     call chem_comm_reduce(lon2d, lonbuf, CHEM_COMM_SUM, comm=tileComm, rc=localrc)
>     if (chem_rc_check(localrc, file=__FILE__, line=__LINE__, rc=rc)) return
> 
>     if (localIOflag) then
> 
>       call chem_io_file_name(datafile, filename, tile, pathname=path)
>         if(present(varname))then
>           if(present(units))then
>             call chem_io_file_writenc2d(datafile, filename,recvbuf,latbuf,lonbuf, &
>             time=time, varname=varname,units=units,rc=localrc)
>           else
>             call chem_io_file_writenc2d(datafile, filename,recvbuf,latbuf,lonbuf, &
>             time=time, varname=varname,rc=localrc)
>           endif
>         else
>           if(present(units))then
>             call chem_io_file_writenc2d(datafile, filename,recvbuf,latbuf,lonbuf, &
>             varname=varname,units=units,rc=localrc)
>           else
>             call chem_io_file_writenc2d(datafile, filename,recvbuf,latbuf,lonbuf, &
>             varname=varname,rc=localrc)
>           endif
>         endif
>       if (chem_rc_check(localrc, file=__FILE__, line=__LINE__, rc=rc)) return
> 
>     end if
> 
>     deallocate(buf2d, recvbuf, stat=localrc)
>     if (chem_rc_test((localrc /= 0), &
>       msg="Cannot deallocate read buffer", &
>       file=__FILE__, line=__LINE__, rc=rc)) return
> 
>   end subroutine chem_io_writenc_2DR4
>   subroutine chem_io_file_writenc2d(datafile, filename,buffer, lat,lon,time,varname, units,rc)
>     use netcdf
>     character(len=*),           intent(in)  :: datafile
>     character(len=*),           intent(in)  :: filename
>     real(CHEM_KIND_R4),         intent(in)  :: buffer(:,:)
>     real(CHEM_KIND_R4),         intent(in)  :: lat(:,:),lon(:,:)
>     integer,optional,intent(in)             :: time
>     integer,          optional, intent(out) :: rc
>     character (len=*), optional, intent(in) :: varname
>     character (len=*), optional, intent(in) :: units
>     integer ncid,ierr,varid,dims(2),ilat,ilon,idimzt,lenf,i
>     real(chem_kind_r4),allocatable :: out(:,:,:)
> 
>     ! -- local variables
>     integer :: localrc
>     real(CHEM_KIND_R4) :: atest
>     integer idimxt,idimyt,idims(3),itime,idims2(2),count(3),start(3)
>     logical dodefine,exist
>     integer idgridxt,idgridyt,idtime
>     real(CHEM_KIND_R8),allocatable :: gridxy(:)
>     real(CHEM_KIND_R8) :: rtime(1)
>     
> 
>     ! -- begin
>     if (present(rc)) rc = CHEM_RC_SUCCESS
> 
>     inquire(file=trim(datafile),exist=exist)
>     if(.not.present(time).and. .not.exist)then
>       ierr=nf90_create(trim(datafile),nf90_clobber+nf90_netcdf4,ncid)
>       if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error create no time',trim(datafile)
>            write(6,*)trim(nf90_strerror(ierr))
>       endif
>       dodefine=.true.
>     else
>       if(exist)then
>         dodefine=.false.
>         ierr=nf90_open(trim(datafile),nf90_write,ncid)
>         ierr=nf90_inq_varid(ncid,varname,varid)
>         if (ierr /= nf90_noerr)then
>           ierr=nf90_inq_dimid(ncid,'grid_xt',idimxt)
>           if (ierr /= nf90_noerr)then
>               write(6,*)'error grid_xt inq'
>               call flush(6)
>           endif
>           ierr=nf90_inq_dimid(ncid,'grid_yt',idimyt)
>           if (ierr /= nf90_noerr)then
>               write(6,*)'error grid_yt inq'
>               call flush(6)
>           endif
>           ierr=nf90_inq_dimid(ncid,'time',itime)
>           if (ierr /= nf90_noerr)then
>               write(6,*)'error time inq'
>               call flush(6)
>           endif
>           idims(1)=idimxt
>           idims(2)=idimyt
>           idims(3)=itime
>           ierr=nf90_redef(ncid)
>           if (ierr /= nf90_noerr)then
>              write(6,*)'error redef'
>               write(6,*)trim(nf90_strerror(ierr))
>           endif
>           ierr=nf90_def_var(ncid,trim(varname),NF90_FLOAT,idims,varid,chunksizes=[dims(1),28,1], &
>               shuffle=.true.,deflate_level=1)
>           if (ierr /= nf90_noerr)then
>               write(6,*)'erroro define ',varname
>               write(6,*)trim(nf90_strerror(ierr))
>           endif
>           if(present(units))then
>             ierr=nf90_put_att(ncid,varid,'units',trim(units))
>             if (ierr /= nf90_noerr)then
>               write(6,*)'error put_att 1,trim(varname),trim(units)'
>               write(6,*)trim(nf90_strerror(ierr))
>             endif
>           endif
>           ierr=nf90_enddef(ncid)
>           if (ierr /= nf90_noerr)then
>                 write(6,*)'error enddef ',varname
>                 write(6,*)trim(nf90_strerror(ierr))
>           endif
>         endif
>       elseif(time<=1)then
>         inquire(file=trim(datafile),exist=exist)
>         if(exist)then
>           dodefine=.false.
>           ierr=nf90_open(trim(datafile),nf90_write,ncid)
>           ierr=nf90_inq_varid(ncid,varname,varid)
>           if (ierr /= nf90_noerr)then
>             ierr=nf90_inq_dimid(ncid,'grid_xt',idimxt)
>             if (ierr /= nf90_noerr)then
>                 write(6,*)'error grid_xt inq'
>                 call flush(6)
>             endif
>             ierr=nf90_inq_dimid(ncid,'grid_yt',idimyt)
>             if (ierr /= nf90_noerr)then
>                 write(6,*)'error grid_yt inq'
>                 call flush(6)
>             endif
>             ierr=nf90_inq_dimid(ncid,'time',itime)
>             if (ierr /= nf90_noerr)then
>                 write(6,*)'error time inq'
>                 call flush(6)
>             endif
>             idims(1)=idimxt
>             idims(2)=idimyt
>             idims(3)=itime
>             ierr=nf90_redef(ncid)
>             if (ierr /= nf90_noerr)then
>                write(6,*)'error redef'
>                 write(6,*)trim(nf90_strerror(ierr))
>             endif
>             ierr=nf90_def_var(ncid,varname,nf90_float,idims,varid)
>             if (ierr /= nf90_noerr)then
>                 write(6,*)'erroro define ',varname
>                 write(6,*)trim(nf90_strerror(ierr))
>             endif
>             if(present(units))then
>                ierr=nf90_put_att(ncid,varid,'units',trim(units))
>               if (ierr /= nf90_noerr)then
>                 write(6,*)'error put_att 2',trim(varname),trim(units)
>                 write(6,*)trim(nf90_strerror(ierr))
>               endif
>             endif
>             ierr=nf90_enddef(ncid)
>             if (ierr /= nf90_noerr)then
>                 write(6,*)'error enddef ',varname
>                 write(6,*)trim(nf90_strerror(ierr))
>             endif
>           endif
>         else
>           write(6,*)'nf90_create',trim(datafile)
>           ierr=nf90_create(trim(datafile),NF90_clobber+nf90_netcdf4,ncid)
>           dodefine=.true.
>         endif
>         if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error create time',trim(datafile)
>            write(6,*)trim(nf90_strerror(ierr))
>         endif
>       else
>         ierr=nf90_open(trim(datafile),NF90_WRITE,ncid)
>         if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error open time',trim(datafile)
>            write(6,*)trim(nf90_strerror(ierr))
>         endif
>         dodefine=.false.
>       endif
>     endif
>     if (ierr /= nf90_noerr)then
>       write(6,*)'zzzz ajl error open ',trim(datafile)
>       call flush(6)
>     endif
>     dims=shape(buffer)
>     allocate (out(dims(1),dims(2),1))
>     out(:,:,1)=buffer(:,:)
>     if(dodefine)then
>       write(6,*)'dims',dims(1:2)
>       ierr=nf90_def_dim(ncid,'grid_xt',dims(1),idimxt)
>       if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error def_dim grid_xt'
>            write(6,*)trim(nf90_strerror(ierr))
>       endif
>       ierr=nf90_def_dim(ncid,'grid_yt',dims(2),idimyt)
>       if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error def_dim grid_yt'
>            write(6,*)trim(nf90_strerror(ierr))
>       endif
>       ierr=nf90_def_dim(ncid,'time',NF90_UNLIMITED,itime)
>       if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error def_dim time'
>            write(6,*)trim(nf90_strerror(ierr))
>       endif
>       ierr=nf90_def_var(ncid,'time',nf90_double,itime,idtime)
>       ierr=nf90_def_var(ncid,'grid_xt',nf90_double,idimxt,idgridxt)
>       ierr=nf90_def_var(ncid,'grid_yt',nf90_double,idimyt,idgridyt)
>       ierr=nf90_put_att(ncid,idtime,'long_name','time')
> !      ierr=nf90_put_att(ncid,idtime,'units','days since '//trim(cdatestr))
>       ierr=nf90_put_att(ncid,idtime,'cartesian_axis','T')
>       ierr=nf90_put_att(ncid,idtime,'calendar_type','JULIAN')
>       ierr=nf90_put_att(ncid,idtime,'calendar','JULIAN')
>       ierr=nf90_put_att(ncid,idgridxt,'long_name','T-cell longitude')
>       ierr=nf90_put_att(ncid,idgridxt,'units','degrees_E')
>       ierr=nf90_put_att(ncid,idgridxt,'cartesian_axis','X')
>       ierr=nf90_put_att(ncid,idgridyt,'long_name','T-cell latitude')
>       ierr=nf90_put_att(ncid,idgridyt,'units','degrees_N')
>       ierr=nf90_put_att(ncid,idgridyt,'cartesian_axis','Y')
>       idims(1)=idimxt
>       idims(2)=idimyt
>       idims(3)=itime
>       idims2(1)=idimxt
>       idims2(2)=idimyt
> 
>       ierr=nf90_def_var(ncid,'lat',nf90_float,idims2,ilat) 
>       if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error def_var write3dnc lat'
>            write(6,*)trim(nf90_strerror(ierr))
>            call flush(6)
>       endif
>       ierr=nf90_def_var(ncid,'lon',nf90_float,idims2,ilon) 
>       if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error def_var lon write3dnc'
>            write(6,*)trim(nf90_strerror(ierr))
>       endif
>       if(present(varname))then
>         ierr=nf90_def_var(ncid,trim(varname),NF90_FLOAT,idims,varid,chunksizes=[dims(1),28,1],shuffle=.true.,deflate_level=1)
>       else
>         ierr=nf90_def_var(ncid,trim(filename),NF90_FLOAT,idims,varid)
>         write(6,*)'no varname'
>       endif
>       if (ierr /= nf90_noerr)then
>            if(present(varname))then
>            write(6,*)'zzzz ajl error def_var varname',varname
>            endif
>            write(6,*)trim(nf90_strerror(ierr))
>       endif
>       if(present(units))then
>         ierr=nf90_put_att(ncid,varid,'units',trim(units))
>         if (ierr /= nf90_noerr)then
>           write(6,*)'error put_att 3',trim(units)
>           write(6,*)trim(nf90_strerror(ierr))
>         endif
>       endif
>       ierr=nf90_enddef(ncid)
>       if (ierr /= nf90_noerr)then
>        write(6,*)'zzzz ajl enddef'
>        write(6,*)trim(nf90_strerror(ierr))
>       endif
> !      rtime=fracday
> !      ierr=nf90_put_var(ncid,idtime,rtime)
>       allocate (gridxy(dims(1)))
>       do i=1,dims(1)
>         gridxy(i)=i
>       end do
>       ierr=nf90_put_var(ncid,idgridxt,gridxy)
>       ierr=nf90_put_var(ncid,idgridyt,gridxy)
>       deallocate(gridxy)
>     endif
>     if(present(time))then
>       start=1
>       start(3)=time
>       count(1)=dims(1)
>       count(2)=dims(2)
>       count(3)=1
>       if(present(varname))then
>         ierr=nf90_inq_varid(ncid,trim(varname),varid)
>       else
>         ierr=nf90_inq_varid(ncid,trim(filename),varid)
>       endif
>       if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error inq_varid bb'
>            write(6,*)trim(nf90_strerror(ierr))
>       endif
>       ierr=nf90_put_var(ncid,varid,out,start=start,count=count)
>       if (ierr /= nf90_noerr)then
>         write(6,*)'put var outtime ',time
>         write(6,*)trim(nf90_strerror(ierr))
>       endif
>     else
>       ierr=nf90_put_var(ncid,varid,out)
>       if (ierr /= nf90_noerr)then
>          write(6,*)'zzzz ajl put var out'
>          write(6,*)trim(nf90_strerror(ierr))
>       endif
>     endif
> !    if(dodefine)then
> !      ierr=nf90_put_var(ncid,ilon,lon)
> !      if (ierr /= nf90_noerr)then
> !        write(6,*)'put_var lon'
> !        write(6,*)trim(nf90_strerror(ierr))
>       !endif
> !      ierr=nf90_put_var(ncid,ilat,lat)
> !      if (ierr /= nf90_noerr)then
> !        write(6,*)'put_var lat'
>         !write(6,*)trim(nf90_strerror(ierr))
> !      endif
> !    endif
>     deallocate (out)
>     ierr=nf90_close(ncid)
>     if (ierr /= nf90_noerr)then
>       write(6,*)'zzzz ajl error close'
>       write(6,*)trim(nf90_strerror(ierr))
>       call flush(6)
>     endif
> 
>   end subroutine chem_io_file_writenc2d
