136c136
<   subroutine chem_io_file_name(fullname, filename, tile, pathname)
---
>   subroutine chem_io_file_name(fullname, filename, tile, pathname,doread)
140a141
>     logical, optional,intent(in)            :: doread
143c144
<     integer :: lstr
---
>     integer :: lstr,lstr2
144a146,147
>     logical exist
> 
153a157,158
>       elseif(filename(lstr-2:lstr) == '.nc')then
>          write(fname,'(a,".tile",i0,".nc")')filename(1:lstr-3),tile
163a169,176
> !        write(6,*)'pathname',trim(pathname)
> !        write(6,*)'lstr',lstr
> !        write(6,*)'len',len(fullname)
> !        call flush(6)
> !        write(6,*)'fname',trim(fname)
> !        call flush(6)
> !        write(6,*)'lstr',pathname(lstr:lstr)
> !        call flush(6)
164a178,182
> !          write(6,*)'176'
> !          call flush(6)
> !          write(6,*)'lenpathname',len_trim(pathname)
> !          write(6,*)'lenfname',len_trim(fname)
> !          call flush(6)
165a184,185
> !          write(6,*)'fullname',len_trim(fullname),trim(fullname)
> !          call flush(6)
166a187,188
> !          write(6,*)'180'
> !          call flush(6)
175a198,216
>     if(present(doread))then
>       inquire(file=fullname,exist=exist)
>       if(exist)return
> !     if not there see if netcdf file is    
>       lstr2=len_trim(fullname)
>       if (fullname(lstr2-3:lstr2) == '.dat')then
>         fullname(lstr2-3:lstr2)='.nc '
>         inquire(file=fullname,exist=exist)
> !       write(6,*)'inquire 2 ',exist,'fullname',trim(fullname)
>         if(exist)return
>         write(6,*)'gsdchemneither .dat nor .nc are there',fullname,'fname',fname
>         call killit('neither')
>       elseif(fullname(lstr2-2:lstr2)=='.nc')then
>         write(6,*)'.nc not there',fullname
>         call killit('.nc')
>       endif
>     endif
>     return
> 
335c376
<   subroutine chem_io_read_2DR4(filename, farray, path, recrange, recsize, recstride, de, rc)
---
>   subroutine chem_io_read_2DR4(filename, farray, path, recrange, recsize, recstride, de, varname, rc)
342a384
>     character(len=*), optional, intent(in)  :: varname
353a396,397
>     logical :: doread=.true.
>     integer lenstr,bsiz1d(1)
371a416
>     bsiz1d(1)=bsize(1)*bsize(2)
376a422
>     allocate(buf2d(its:ite,jts:jte), stat=localrc)
380,381c426,438
<       call chem_io_file_name(datafile, filename, tile, pathname=path)
< 
---
>       call chem_io_file_name(datafile, filename, tile, pathname=path,doread=doread)
>       lenstr=len_trim(datafile)
> !      write(6,*)'lenstr',lenstr,'datafile',trim(datafile)
> !      call flush(6)
>       if(datafile(lenstr-2:lenstr)=='.nc')then
>         if(present(varname))then
>           call chem_io_file_read_2d_nc(datafile, buf2d, recrange=recrange, &
>           recsize=recsize, recstride=recstride, varname=varname,rc=localrc)
>           buffer=reshape(buf2d,bsiz1d)
>         else 
>           write(6,*)'netcdf file without varname',trim(filename)
>         endif
>       else 
383a441
>       endif
394d451
<     allocate(buf2d(its:ite,jts:jte), stat=localrc)
411c468
<   subroutine chem_io_read_3DR4(filename, farray, path, recrange, recsize, recstride, de, rc)
---
>   subroutine chem_io_read_3DR4(filename, farray, path, recrange, recsize, recstride, de, varname, rc)
418a476
>     character(len=*), optional, intent(in)  :: varname
429a488,489
>     integer bsiz1d(1),lenstr
>     logical :: doread=.true.
442a503
>     bsiz1d=bsize(1)*bsize(2)*bsize(3)
453a515
>     allocate(buf3d(its:ite,jts:jte,bsize(3)), stat=localrc)
456,457c518,536
< 
<       call chem_io_file_name(datafile, filename, tile, pathname=path)
---
> !      write(6,*)'len datafile',len(datafile)
> !      call flush(6)
> !      write(6,*)'len filename',len_trim(filename)
> !      write(6,*)'len path',len_trim(path)
> !      call flush(6)
> 
>       call chem_io_file_name(datafile, filename, tile, pathname=path,doread=doread)
>       lenstr=len_trim(datafile)
> !      write(6,*)'lenstr3d',lenstr,'datafile',trim(datafile)
> !      call flush(6)
>       if(datafile(lenstr-2:lenstr)=='.nc')then
>         if(present(varname))then
>           call chem_io_file_read_3d_nc(datafile, buf3d, recrange=recrange, &
>           recsize=recsize, recstride=recstride, varname=varname,rc=localrc)
>           buffer=reshape(buf3d,bsiz1d)
>         else
>           write(6,*)'netcdf file without varname',trim(filename)
>         endif
>       else
460a540
>       endif
471d550
<     allocate(buf3d(its:ite,jts:jte,bsize(3)), stat=localrc)
1047a1127,1721
> ! add for netcdf files ajl
> 
>   subroutine chem_io_file_read_2d_nc(datafile, buffer, recrange, recsize, recstride, varname,rc)
>     use chem_comm_mod, only : chem_comm_get
>     use netcdf
>     character(len=*),   intent(in)  :: datafile
>     real(CHEM_KIND_R4), intent(out) :: buffer(:,:)
>     integer, optional,  intent(in)  :: recrange(2)
>     integer, optional,  intent(in)  :: recsize
>     integer, optional,  intent(in)  :: recstride
>     character(len=*), optional,  intent(in)  :: varname
>     character*120 namevar
>     integer, optional,  intent(out) :: rc
>      
> 
>     ! -- local variables
>     integer :: localrc
>     integer :: irec, is, ie,i
>     integer :: rcount, rsize, rstride
>     integer :: rrange(2)
>     integer :: nc,nr
>     integer :: mype
>     integer :: ncid ! ncid for netcdf file
>     integer :: ierr ! netcdf error code
>     integer :: varid ! netcdf varid
>     if(.not.present(varname))then
>       rc=1
>       write(6,*)'varname must be present for reading netcdf file input'
>       call flush(6)
>       return
>     endif
> !    write(6,*)'read_2d_nc var',trim(varname)
> !    call flush(6)
>     call chem_comm_get(localpe=mype)
> !    write(6,*)'chem_io_file_read_2d_nc mype',mype,shape(buffer)
> !    call flush(6)
> 
>     ! -- begin
>     if (present(rc)) rc = CHEM_RC_SUCCESS
> !    return ! for now
> 
>     buffer = 0._CHEM_KIND_R4
> 
>     if (present(recrange)) then
>       rrange = recrange
>     else
>       rrange = 1
>     end if
>     rcount = rrange(2) - rrange(1) + 1
> 
>     if (present(recsize)) then
>       rsize = recsize
>     else
>       rsize = size(buffer) / rcount
>     end if
> 
>     if (present(recstride)) then
>       rstride = recstride
>     else
>       rstride = rsize
>     end if
> !    write(6,*)'sizebuffer',size(buffer),'rcount',rcount,'rsize',rsize,'rstride',rstride
> !    write(70+mype,*)'sizebuffer',size(buffer),'rcount',rcount,'rsize',rsize,'rstride',rstride
> !    call flush(70+mype)
> !    write(6,*)'prod ',rcount * max(rsize, rstride)
> !    call flush(6)
> 
>     if (chem_rc_test((size(buffer) < rcount * max(rsize, rstride)), &
>         msg="insufficient buffer size", &
>         file=__FILE__, line=__LINE__, rc=rc)) return
> 
>     ! -- open file
> !    write(70+mype,*)'open',trim(datafile)
> !    call flush(70+mype)
>     ierr=nf90_open(trim(datafile),0,ncid)
>     if (ierr /= nf90_noerr)then
>        write(6,*)'error open ',trim(datafile)
>        call flush(6)
>        rc=1
>        return
>     else
> !      if(mype.eq.0)then
> !        write(6,*)'open 2d nc ',trim(datafile)
> !        call flush(6)
> !      endif
>     endif
>     ierr=nf90_inq_varid(ncid,trim(varname),varid)
>     if (ierr /= nf90_noerr)then
>       write(6,*)'error getting varid for ',trim(varname),' file ',trim(datafile)
>       write(6,*)trim(nf90_strerror(ierr))
>       call flush(6)
>       do i=1,3
>         ierr=nf90_inquire_variable(ncid,i,name=namevar)
>         write(6,*)'namevar',i,trim(namevar)
>         call flush(6)
>       end do
>       rc=1
>       return
> !    else
> !      write(6,*)'read id ',trim(varname),varid
> !      call flush(6)
>     endif
>     ierr=nf90_get_var(ncid,varid,buffer)
>     if (ierr /= nf90_noerr)then
>       write(6,*)'error getting var size buffer',shape(buffer),'var',trim(varname),'file',trim(datafile)
>       write(6,*)trim(nf90_strerror(ierr))
>       call flush(6)
>       rc=1
>       return
>     else
> !      if(mype.eq.0)then
> !        write(6,*)'read var',maxval(buffer),minval(buffer)
> !        call flush(6)
> !      endif
>     endif
> 
> 
>     ! -- close file
>      ierr=nf90_close(ncid)
> 
>   end subroutine chem_io_file_read_2d_nc
>   subroutine chem_io_file_read_3d_nc(datafile, buffer, recrange, recsize, recstride, varname,rc)
>     use chem_comm_mod, only : chem_comm_get
>     use netcdf
>     character(len=*),   intent(in)  :: datafile
>     real(CHEM_KIND_R4), intent(out) :: buffer(:,:,:)
>     integer, optional,  intent(in)  :: recrange(2)
>     integer, optional,  intent(in)  :: recsize
>     integer, optional,  intent(in)  :: recstride
>     character(len=*), optional,  intent(in)  :: varname
>     integer, optional,  intent(out) :: rc
> 
>     ! -- local variables
>     integer :: localrc
>     integer :: irec, is, ie
>     integer :: rcount, rsize, rstride
>     integer :: rrange(2)
>     integer :: nc,nr
>     integer :: mype
>     integer :: ncid ! ncid for netcdf file
>     integer :: ierr ! netcdf error code
>     integer :: varid ! netcdf varid
>     if(.not.present(varname))then
>       rc=1
>       write(6,*)'varname must be present for reading netcdf file input'
>       call flush(6)
>       return
>     endif
>     call chem_comm_get(localpe=mype)
> 
>     ! -- begin
>     if (present(rc)) rc = CHEM_RC_SUCCESS
> 
>     buffer = 0._CHEM_KIND_R4
> 
>     if (present(recrange)) then
>       rrange = recrange
>     else
>       rrange = 1
>     end if
>     rcount = rrange(2) - rrange(1) + 1
> 
>     if (present(recsize)) then
>       rsize = recsize
>     else
>       rsize = size(buffer) / rcount
>     end if
> 
>     if (present(recstride)) then
>       rstride = recstride
>     else
>       rstride = rsize
>     end if
> 
>     if (chem_rc_test((size(buffer) < rcount * max(rsize, rstride)), &
>         msg="insufficient buffer size", &
>         file=__FILE__, line=__LINE__, rc=rc)) return
> 
>     ! -- open file
>     ierr=nf90_open(trim(datafile),0,ncid)
>     if (ierr /= nf90_noerr)then
>        write(6,*)'error open ',trim(datafile)
>        call flush(6)
>        rc=1
>        return
>     endif
>     ierr=nf90_inq_varid(ncid,trim(varname),varid)
>     if (ierr /= nf90_noerr)then
>       write(6,*)'error getting varid for ',trim(varname),' file ',trim(datafile)
>       write(6,*)trim(nf90_strerror(ierr))
>       rc=1
>       return
>     endif
>     ierr=nf90_get_var(ncid,varid,buffer)
>     if (ierr /= nf90_noerr)then
>       write(6,*)'error getting var size buffer',shape(buffer),'var',trim(varname),'file',trim(datafile)
>       write(6,*)trim(nf90_strerror(ierr))
>       call flush(6)
>       rc=1
>       return
>     endif
>      ierr=nf90_close(ncid)
> 
>   end subroutine chem_io_file_read_3d_nc
> 
> 
>   subroutine chem_io_writenc_2DR4(filename, farray, path, pos, de, time,varname,units,rc)
>     use netcdf
>     use chem_comm_mod, only : chem_comm_get
> !    use raqmschem_pmgrid_mod, only : iam
>     character(len=*),           intent(in)  :: filename
>     real(CHEM_KIND_R4),         intent(in)  :: farray(:,:)
>     character(len=*), optional, intent(in)  :: path
>     character(len=*), optional, intent(in)  :: pos
>     integer,          optional, intent(in)  :: de
>     integer,          optional, intent(in)  :: time
>     character(len=*),optional,  intent(in)  :: varname
>     character(len=*),optional,  intent(in)  :: units
>     integer,          optional, intent(out) :: rc
> 
>     ! -- local variables
>     integer :: localrc
>     integer :: tile, tileComm
>     integer :: ids, ide, jds, jde, its, ite, jts, jte
>     logical :: localIOflag
>     character(len=CHEM_MAXSTR) :: datafile
>     real(CHEM_KIND_R4), dimension(:,:), allocatable, target :: buf2d, recvbuf
>     real(chem_kind_R8), pointer, dimension(:,: ) :: lat2dr8,lon2dr8
>     real(chem_kind_R4), pointer, dimension(:,: ) :: lat2d,lon2d,latbuf,lonbuf
>     integer ncid,ierr,lenf,mype
>     lenf=len_trim(filename)
> 
>     ! -- begin
>     if (present(rc)) rc = CHEM_RC_SUCCESS
>     call chem_comm_get(localpe=mype)
> 
>     call chem_model_get(de=de, tile=tile, tileComm=tileComm, &
>       localIOflag=localIOflag, rc=localrc)
>     if (chem_rc_check(localrc, file=__FILE__, line=__LINE__, rc=rc)) return
>     call chem_model_domain_get(de=de, ids=ids, ide=ide, jds=jds, jde=jde, &
>       its=its, ite=ite, jts=jts, jte=jte, lon=lon2dr8,lat=lat2dr8,rc=localrc)
>     if (chem_rc_check(localrc, file=__FILE__, line=__LINE__, rc=rc)) return
> 
>     ! -- check size consistency
>     if (chem_rc_test((size(farray) /= (ide-ids+1)*(jde-jds+1)), &
>       msg="size of input array inconsistent with domain decomposition", &
>       file=__FILE__, line=__LINE__, rc=rc)) return
> 
>     allocate(buf2d(its:ite,jts:jte), stat=localrc)
>     if (chem_rc_test((localrc /= 0), &
>       msg="Cannot allocate read buffer", &
>       file=__FILE__, line=__LINE__, rc=rc)) return
>     buf2d = 0._CHEM_KIND_R4
> 
>     buf2d(ids:ide, jds:jde) = farray
> 
>     allocate(recvbuf(its:ite,jts:jte), stat=localrc)
>     allocate(lonbuf(its:ite,jts:jte), stat=localrc)
>     allocate(latbuf(its:ite,jts:jte), stat=localrc)
>     allocate(lat2d(its:ite,jts:jte))
>     allocate(lon2d(its:ite,jts:jte))
>     lat2d=0.
>     lon2d=0.
>     lat2d(ids:ide,jds:jde)=lat2dr8
>     lon2d(ids:ide,jds:jde)=lon2dr8
>     if (chem_rc_test((localrc /= 0), &
>       msg="Cannot allocate read buffer", &
>       file=__FILE__, line=__LINE__, rc=rc)) return
> 
>     recvbuf = 0._CHEM_KIND_R4
>     latbuf=0._CHEM_KIND_R4
>     lonbuf=0._CHEM_KIND_R4
> 
>     call chem_comm_reduce(buf2d, recvbuf, CHEM_COMM_SUM, comm=tileComm, rc=localrc)
>     if (chem_rc_check(localrc, file=__FILE__, line=__LINE__, rc=rc)) return
>     call chem_comm_reduce(lat2d, latbuf, CHEM_COMM_SUM, comm=tileComm, rc=localrc)
>     if (chem_rc_check(localrc, file=__FILE__, line=__LINE__, rc=rc)) return
>     call chem_comm_reduce(lon2d, lonbuf, CHEM_COMM_SUM, comm=tileComm, rc=localrc)
>     if (chem_rc_check(localrc, file=__FILE__, line=__LINE__, rc=rc)) return
> 
>     if (localIOflag) then
> 
>       call chem_io_file_name(datafile, filename, tile, pathname=path)
>         if(present(varname))then
>           if(present(units))then
>             call chem_io_file_writenc2d(datafile, filename,recvbuf,latbuf,lonbuf, &
>             time=time, varname=varname,units=units,rc=localrc)
>           else
>             call chem_io_file_writenc2d(datafile, filename,recvbuf,latbuf,lonbuf, &
>             time=time, varname=varname,rc=localrc)
>           endif
>         else
>           if(present(units))then
>             call chem_io_file_writenc2d(datafile, filename,recvbuf,latbuf,lonbuf, &
>             varname=varname,units=units,rc=localrc)
>           else
>             call chem_io_file_writenc2d(datafile, filename,recvbuf,latbuf,lonbuf, &
>             varname=varname,rc=localrc)
>           endif
>         endif
>       if (chem_rc_check(localrc, file=__FILE__, line=__LINE__, rc=rc)) return
> 
>     end if
> 
>     deallocate(buf2d, recvbuf, stat=localrc)
>     if (chem_rc_test((localrc /= 0), &
>       msg="Cannot deallocate read buffer", &
>       file=__FILE__, line=__LINE__, rc=rc)) return
> 
>   end subroutine chem_io_writenc_2DR4
>   subroutine chem_io_file_writenc2d(datafile, filename,buffer, lat,lon,time,varname, units,rc)
>     use netcdf
>     character(len=*),           intent(in)  :: datafile
>     character(len=*),           intent(in)  :: filename
>     real(CHEM_KIND_R4),         intent(in)  :: buffer(:,:)
>     real(CHEM_KIND_R4),         intent(in)  :: lat(:,:),lon(:,:)
>     integer,optional,intent(in)             :: time
>     integer,          optional, intent(out) :: rc
>     character (len=*), optional, intent(in) :: varname
>     character (len=*), optional, intent(in) :: units
>     integer ncid,ierr,varid,dims(2),ilat,ilon,idimzt,lenf,i
>     real(chem_kind_r4),allocatable :: out(:,:,:)
> 
>     ! -- local variables
>     integer :: localrc
>     real(CHEM_KIND_R4) :: atest
>     integer idimxt,idimyt,idims(3),itime,idims2(2),count(3),start(3)
>     logical dodefine,exist
>     integer idgridxt,idgridyt,idtime
>     real(CHEM_KIND_R8),allocatable :: gridxy(:)
>     real(CHEM_KIND_R8) :: rtime(1)
>     
> 
>     ! -- begin
>     if (present(rc)) rc = CHEM_RC_SUCCESS
> 
>     inquire(file=trim(datafile),exist=exist)
>     if(.not.present(time).and. .not.exist)then
>       ierr=nf90_create(trim(datafile),nf90_clobber+nf90_netcdf4,ncid)
>       if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error create no time',trim(datafile)
>            write(6,*)trim(nf90_strerror(ierr))
>       endif
>       dodefine=.true.
>     else
>       if(exist)then
>         dodefine=.false.
>         ierr=nf90_open(trim(datafile),nf90_write,ncid)
>         ierr=nf90_inq_varid(ncid,varname,varid)
>         if (ierr /= nf90_noerr)then
>           ierr=nf90_inq_dimid(ncid,'grid_xt',idimxt)
>           if (ierr /= nf90_noerr)then
>               write(6,*)'error grid_xt inq'
>               call flush(6)
>           endif
>           ierr=nf90_inq_dimid(ncid,'grid_yt',idimyt)
>           if (ierr /= nf90_noerr)then
>               write(6,*)'error grid_yt inq'
>               call flush(6)
>           endif
>           ierr=nf90_inq_dimid(ncid,'time',itime)
>           if (ierr /= nf90_noerr)then
>               write(6,*)'error time inq'
>               call flush(6)
>           endif
>           idims(1)=idimxt
>           idims(2)=idimyt
>           idims(3)=itime
>           ierr=nf90_redef(ncid)
>           if (ierr /= nf90_noerr)then
>              write(6,*)'error redef'
>               write(6,*)trim(nf90_strerror(ierr))
>           endif
>           ierr=nf90_def_var(ncid,trim(varname),NF90_FLOAT,idims,varid,chunksizes=[dims(1),28,1], &
>               shuffle=.true.,deflate_level=1)
>           if (ierr /= nf90_noerr)then
>               write(6,*)'erroro define ',varname
>               write(6,*)trim(nf90_strerror(ierr))
>           endif
>           if(present(units))then
>             ierr=nf90_put_att(ncid,varid,'units',trim(units))
>             if (ierr /= nf90_noerr)then
>               write(6,*)'error put_att 1,trim(varname),trim(units)'
>               write(6,*)trim(nf90_strerror(ierr))
>             endif
>           endif
>           ierr=nf90_enddef(ncid)
>           if (ierr /= nf90_noerr)then
>                 write(6,*)'error enddef ',varname
>                 write(6,*)trim(nf90_strerror(ierr))
>           endif
>         endif
>       elseif(time<=1)then
>         inquire(file=trim(datafile),exist=exist)
>         if(exist)then
>           dodefine=.false.
>           ierr=nf90_open(trim(datafile),nf90_write,ncid)
>           ierr=nf90_inq_varid(ncid,varname,varid)
>           if (ierr /= nf90_noerr)then
>             ierr=nf90_inq_dimid(ncid,'grid_xt',idimxt)
>             if (ierr /= nf90_noerr)then
>                 write(6,*)'error grid_xt inq'
>                 call flush(6)
>             endif
>             ierr=nf90_inq_dimid(ncid,'grid_yt',idimyt)
>             if (ierr /= nf90_noerr)then
>                 write(6,*)'error grid_yt inq'
>                 call flush(6)
>             endif
>             ierr=nf90_inq_dimid(ncid,'time',itime)
>             if (ierr /= nf90_noerr)then
>                 write(6,*)'error time inq'
>                 call flush(6)
>             endif
>             idims(1)=idimxt
>             idims(2)=idimyt
>             idims(3)=itime
>             ierr=nf90_redef(ncid)
>             if (ierr /= nf90_noerr)then
>                write(6,*)'error redef'
>                 write(6,*)trim(nf90_strerror(ierr))
>             endif
>             ierr=nf90_def_var(ncid,varname,nf90_float,idims,varid)
>             if (ierr /= nf90_noerr)then
>                 write(6,*)'erroro define ',varname
>                 write(6,*)trim(nf90_strerror(ierr))
>             endif
>             if(present(units))then
>                ierr=nf90_put_att(ncid,varid,'units',trim(units))
>               if (ierr /= nf90_noerr)then
>                 write(6,*)'error put_att 2',trim(varname),trim(units)
>                 write(6,*)trim(nf90_strerror(ierr))
>               endif
>             endif
>             ierr=nf90_enddef(ncid)
>             if (ierr /= nf90_noerr)then
>                 write(6,*)'error enddef ',varname
>                 write(6,*)trim(nf90_strerror(ierr))
>             endif
>           endif
>         else
>           write(6,*)'nf90_create',trim(datafile)
>           ierr=nf90_create(trim(datafile),NF90_clobber+nf90_netcdf4,ncid)
>           dodefine=.true.
>         endif
>         if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error create time',trim(datafile)
>            write(6,*)trim(nf90_strerror(ierr))
>         endif
>       else
>         ierr=nf90_open(trim(datafile),NF90_WRITE,ncid)
>         if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error open time',trim(datafile)
>            write(6,*)trim(nf90_strerror(ierr))
>         endif
>         dodefine=.false.
>       endif
>     endif
>     if (ierr /= nf90_noerr)then
>       write(6,*)'zzzz ajl error open ',trim(datafile)
>       call flush(6)
>     endif
>     dims=shape(buffer)
>     allocate (out(dims(1),dims(2),1))
>     out(:,:,1)=buffer(:,:)
>     if(dodefine)then
>       write(6,*)'dims',dims(1:2)
>       ierr=nf90_def_dim(ncid,'grid_xt',dims(1),idimxt)
>       if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error def_dim grid_xt'
>            write(6,*)trim(nf90_strerror(ierr))
>       endif
>       ierr=nf90_def_dim(ncid,'grid_yt',dims(2),idimyt)
>       if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error def_dim grid_yt'
>            write(6,*)trim(nf90_strerror(ierr))
>       endif
>       ierr=nf90_def_dim(ncid,'time',NF90_UNLIMITED,itime)
>       if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error def_dim time'
>            write(6,*)trim(nf90_strerror(ierr))
>       endif
>       ierr=nf90_def_var(ncid,'time',nf90_double,itime,idtime)
>       ierr=nf90_def_var(ncid,'grid_xt',nf90_double,idimxt,idgridxt)
>       ierr=nf90_def_var(ncid,'grid_yt',nf90_double,idimyt,idgridyt)
>       ierr=nf90_put_att(ncid,idtime,'long_name','time')
> !      ierr=nf90_put_att(ncid,idtime,'units','days since '//trim(cdatestr))
>       ierr=nf90_put_att(ncid,idtime,'cartesian_axis','T')
>       ierr=nf90_put_att(ncid,idtime,'calendar_type','JULIAN')
>       ierr=nf90_put_att(ncid,idtime,'calendar','JULIAN')
>       ierr=nf90_put_att(ncid,idgridxt,'long_name','T-cell longitude')
>       ierr=nf90_put_att(ncid,idgridxt,'units','degrees_E')
>       ierr=nf90_put_att(ncid,idgridxt,'cartesian_axis','X')
>       ierr=nf90_put_att(ncid,idgridyt,'long_name','T-cell latitude')
>       ierr=nf90_put_att(ncid,idgridyt,'units','degrees_N')
>       ierr=nf90_put_att(ncid,idgridyt,'cartesian_axis','Y')
>       idims(1)=idimxt
>       idims(2)=idimyt
>       idims(3)=itime
>       idims2(1)=idimxt
>       idims2(2)=idimyt
> 
>       ierr=nf90_def_var(ncid,'lat',nf90_float,idims2,ilat) 
>       if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error def_var write3dnc lat'
>            write(6,*)trim(nf90_strerror(ierr))
>            call flush(6)
>       endif
>       ierr=nf90_def_var(ncid,'lon',nf90_float,idims2,ilon) 
>       if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error def_var lon write3dnc'
>            write(6,*)trim(nf90_strerror(ierr))
>       endif
>       if(present(varname))then
>         ierr=nf90_def_var(ncid,trim(varname),NF90_FLOAT,idims,varid,chunksizes=[dims(1),28,1],shuffle=.true.,deflate_level=1)
>       else
>         ierr=nf90_def_var(ncid,trim(filename),NF90_FLOAT,idims,varid)
>         write(6,*)'no varname'
>       endif
>       if (ierr /= nf90_noerr)then
>            if(present(varname))then
>            write(6,*)'zzzz ajl error def_var varname',varname
>            endif
>            write(6,*)trim(nf90_strerror(ierr))
>       endif
>       if(present(units))then
>         ierr=nf90_put_att(ncid,varid,'units',trim(units))
>         if (ierr /= nf90_noerr)then
>           write(6,*)'error put_att 3',trim(units)
>           write(6,*)trim(nf90_strerror(ierr))
>         endif
>       endif
>       ierr=nf90_enddef(ncid)
>       if (ierr /= nf90_noerr)then
>        write(6,*)'zzzz ajl enddef'
>        write(6,*)trim(nf90_strerror(ierr))
>       endif
> !      rtime=fracday
> !      ierr=nf90_put_var(ncid,idtime,rtime)
>       allocate (gridxy(dims(1)))
>       do i=1,dims(1)
>         gridxy(i)=i
>       end do
>       ierr=nf90_put_var(ncid,idgridxt,gridxy)
>       ierr=nf90_put_var(ncid,idgridyt,gridxy)
>       deallocate(gridxy)
>     endif
>     if(present(time))then
>       start=1
>       start(3)=time
>       count(1)=dims(1)
>       count(2)=dims(2)
>       count(3)=1
>       if(present(varname))then
>         ierr=nf90_inq_varid(ncid,trim(varname),varid)
>       else
>         ierr=nf90_inq_varid(ncid,trim(filename),varid)
>       endif
>       if (ierr /= nf90_noerr)then
>            write(6,*)'zzzz ajl error inq_varid bb'
>            write(6,*)trim(nf90_strerror(ierr))
>       endif
>       ierr=nf90_put_var(ncid,varid,out,start=start,count=count)
>       if (ierr /= nf90_noerr)then
>         write(6,*)'put var outtime ',time
>         write(6,*)trim(nf90_strerror(ierr))
>       endif
>     else
>       ierr=nf90_put_var(ncid,varid,out)
>       if (ierr /= nf90_noerr)then
>          write(6,*)'zzzz ajl put var out'
>          write(6,*)trim(nf90_strerror(ierr))
>       endif
>     endif
> !    if(dodefine)then
> !      ierr=nf90_put_var(ncid,ilon,lon)
> !      if (ierr /= nf90_noerr)then
> !        write(6,*)'put_var lon'
> !        write(6,*)trim(nf90_strerror(ierr))
>       !endif
> !      ierr=nf90_put_var(ncid,ilat,lat)
> !      if (ierr /= nf90_noerr)then
> !        write(6,*)'put_var lat'
>         !write(6,*)trim(nf90_strerror(ierr))
> !      endif
> !    endif
>     deallocate (out)
>     ierr=nf90_close(ncid)
>     if (ierr /= nf90_noerr)then
>       write(6,*)'zzzz ajl error close'
>       write(6,*)trim(nf90_strerror(ierr))
>       call flush(6)
>     endif
> 
>   end subroutine chem_io_file_writenc2d
