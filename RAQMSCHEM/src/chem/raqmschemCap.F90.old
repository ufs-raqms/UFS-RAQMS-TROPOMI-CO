module RAQMSCHM
  !-----------------------------------------------------------------------------
  ! CHM Component.
  !-----------------------------------------------------------------------------

  use ESMF
  use NUOPC
  use NUOPC_Model, inheritModel => SetServices

  use raqmschem_methods
  use chem_types_mod, only :CHEM_KIND_R8
  
  implicit none

  ! -- import fields
!  integer, parameter :: importFieldCount = 25
!  integer, parameter :: importFieldCount = 26
  integer, parameter :: importFieldCount = 28
  character(len=*), dimension(importFieldCount), parameter :: &
    importFieldNames = (/ &
      "inst_pres_interface                  ", &
      "inst_pres_levels                     ", &
      "inst_geop_interface                  ", &
      "inst_geop_levels                     ", &
      "inst_temp_levels                     ", &
      "inst_zonal_wind_levels               ", &
      "inst_merid_wind_levels               ", &
      "inst_omega_levels                    ", &
      "inst_cldtau                          ", &
      "inst_tracer_mass_frac                ", &
      "soil_type                            ", &
      "inst_pbl_height                      ", &
      "surface_cell_area                    ", &
      "inst_convective_rainfall_amount      ", &
      "inst_exchange_coefficient_heat_levels", &
      "inst_friction_velocity               ", &
      "inst_rainfall_amount                 ", &
      "inst_soil_moisture_content           ", &
      "inst_down_sw_flx                     ", &
      "inst_land_sea_mask                   ", &
      "inst_temp_height_surface             ", &
      "inst_up_sensi_heat_flx               ", &
      "inst_lwe_snow_thickness              ", &
      "vegetation_type                      ", &
      "inst_vegetation_area_frac            ", &
      "inst_surface_roughness               ", &
      "cm_drag                              ", &
      "ktop_kbot_cnv                        "  &
    /)
  ! -- export fields
  integer, parameter :: exportFieldCount = 1
  character(len=*), dimension(exportFieldCount), parameter :: &
    exportFieldNames = (/ &
      "raqms_inst_tracer_mass_frac          "  &
    /)

  ! -- verbosity
  integer :: verbosity

  private
  
  public SetServices
  
  !-----------------------------------------------------------------------------
  contains
  !-----------------------------------------------------------------------------
  
  subroutine SetServices(model, rc)
    type(ESMF_GridComp)  :: model
    integer, intent(out) :: rc

    ! begin
    rc = ESMF_SUCCESS
    
    ! the NUOPC model component will register the generic methods
!    write(6,*)'ajl top raqmschem setservices 8.7'
!    call flush(6)
    call NUOPC_CompDerive(model, inheritModel, rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out

    ! Provide InitializeP0 to switch from default IPDv00 to IPDv03
    call ESMF_GridCompSetEntryPoint(model, ESMF_METHOD_INITIALIZE, &
      userRoutine=InitializeP0, phase=0, rc=rc)
!    write(6,*)'ajl raqms set service initp0',rc
!    call flush(6)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out

    ! set entry point for methods that require specific implementation
    call NUOPC_CompSetEntryPoint(model, ESMF_METHOD_INITIALIZE, &
      phaseLabelList=(/"IPDv03p1"/), userRoutine=InitializeP1, rc=rc)
!    write(6,*)'ajl raqms initp1',rc
!    call flush(6)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out

    ! attach specializing method(s)
    call NUOPC_CompSpecialize(model, specLabel=label_DataInitialize, &
      specRoutine=raqDataInitialize, rc=rc)
!    write(6,*)'ajl raqms datgainitialize',rc
!    call flush(6)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out
    call NUOPC_CompSpecialize(model, specLabel=label_Advance, &
      specRoutine=raqModelAdvance, rc=rc)
!    write(6,*)'ajl raqms model advance',rc
!    call flush(6)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out
!   ajl add new call from April 4th version
!   they removed this on 8.7
!    call ESMF_MethodRemove(model, label=label_CheckImport, rc=rc)
!    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
!      line=__LINE__, &
!      file=__FILE__)) &
!      return  ! bail out
!    call NUOPC_CompSpecialize(model, specLabel=label_CheckImport, &
!      specRoutine=raqCheckImport, rc=rc)
!    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
!      line=__LINE__, &
!      file=__FILE__)) &
!      return  ! bail out
    call NUOPC_CompSpecialize(model, specLabel=label_Finalize, &
      specRoutine=ModelFinalize, rc=rc)
!    write(6,*)'ajl raqms model final'
!    call flush(6)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out
!    write(6,*)'ajl bottom raqms setservices'
!    call flush(6)

  end subroutine
  
  !-----------------------------------------------------------------------------

  subroutine InitializeP0(model, importState, exportState, clock, rc)
    type(ESMF_GridComp)  :: model
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: clock
    integer, intent(out) :: rc
    
    ! local variables
    character(len=5)     :: value

    ! begin
    rc = ESMF_SUCCESS

    ! get component verbosity
!    write(6,*)'ajl raqmschem  top p0'
!    call flush(6)
    call ESMF_AttributeGet(model, name="Verbosity", value=value, &
      defaultValue="min", convention="NUOPC", purpose="Instance", rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out
    ! convert value to verbosity
    verbosity = ESMF_UtilString2Int(value, &
      specialStringList=(/"min ","high", "max "/), &
      specialValueList=(/0,255,255/), rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out
    ! write to log files
    call ESMF_LogWrite("RCHM: Verbosity = " // trim(value), &
      ESMF_LOGMSG_INFO, rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out

    ! switch to IPDv03 by filtering all other phaseMap entries
    call NUOPC_CompFilterPhaseMap(model, ESMF_METHOD_INITIALIZE, &
      acceptStringList=(/"IPDv03p"/), rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out
!    write(6,*)'bottom ajl raqms p0'
!    call flush(6)
    
  end subroutine
  
  !-----------------------------------------------------------------------------
  subroutine InitializeP1(model, importState, exportState, clock, rc)
    type(ESMF_GridComp)  :: model
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: clock
    integer, intent(out) :: rc
    integer i
    
    ! begin
    rc = ESMF_SUCCESS
!    write(6,*)'top initializep1 raqms',importfieldcount
!    call flush(6)
!    write(6,*)'import field namees',importfieldnames
!    call flush(6)

    ! -- advertise imported fields
    if (importFieldCount > 0) then
      call NUOPC_Advertise(importState, importFieldNames, &
        TransferOfferGeomObject="cannot provide", &
        TransferOfferField="cannot provide", &
        SharePolicyField="share", &
        rc=rc)
!      write(6,*)'advertise rc=',rc
!      call flush(6)
      
      if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
        line=__LINE__, &
        file=__FILE__)) &
        return  ! bail out
    end if
!    write(6,*)'init p1 raqmsx export',exportfieldcount
!    call flush(6)

    ! -- advertise exported fields
    if (exportFieldCount > 0) then
      call NUOPC_Advertise(exportState, exportFieldNames, &
        TransferOfferGeomObject="cannot provide", &
        TransferOfferField="cannot provide", &
        SharePolicyField="share", &
        rc=rc)
      if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
        line=__LINE__, &
        file=__FILE__)) &
        return  ! bail out
    end if
!    write(6,*)'bottom raqms initp1'
!    call flush(6)

  end subroutine

  !-----------------------------------------------------------------------------

  subroutine raqDataInitialize(model, rc)
    use raqmschem_io_mod,only : raqmschem_io_init
    use raqmschem_iodata_mod
    use chem_comm_mod, only : chem_comm_get
    type(ESMF_GridComp)  :: model
    integer, intent(out) :: rc

    ! local variables
    type(ESMF_State)              :: importState, exportState
    type(ESMF_Field)              :: field
    type(ESMF_Clock)              :: clock
    type(ESMF_Grid)               :: grid
    type(ESMF_VM)                 :: vm
    type(ESMF_GeomType_flag)      :: geomtype
    type(ESMF_DistGrid)           :: distgrid
    type(ESMF_Array)              :: array
    integer                       :: de, item, localrc, localDe, tile
    integer                       :: comm, localPet
    real(ESMF_KIND_R8), dimension(:,:), pointer :: coord

    integer :: dimCount, tileCount, deCount, localDeCount
    integer, dimension(:),   allocatable :: deToTileMap, localDeToDeMap
    integer, dimension(:,:), allocatable :: minIndexPDe, maxIndexPDe, minIndexPTile, maxIndexPTile
    integer, dimension(:,:), allocatable :: computationalLBound, computationalUBound

    integer                    :: yy, mm, dd, h, m
    real(ESMF_KIND_R8)         :: dts
    type(ESMF_Time)            :: startTime
    type(ESMF_TimeInterval)    :: TimeStep
    character(len=255) :: msgString
    logical bigendian
    integer mype
    bigendian=.true.

    ! begin
    rc = ESMF_SUCCESS

    ! -- initialize chemistry model
!    write(6,*)'ajl raqmschem top DataInitialize'
!    call flush(6)
    call ESMF_GridCompGet(model, vm=vm, rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out
!    write(6,*)'ajl importfieldcount',importfieldcount
!    call flush(6)

    ! -- check if import fields are defined
    if (importFieldCount < 1) then 
      call ESMF_LogSetError(ESMF_RC_NOT_IMPL, &
        msg="This component requires import fields to be defined.", &
        line=__LINE__, file=__FILE__, &
        rcToReturn=rc)
      return  ! bail out
    end if
!    write(6,*)'exportfieldcount',exportfieldcount
!    call flush(6)

    ! -- check if export fields are defined
    if (exportFieldCount < 1) then 
      call ESMF_LogSetError(ESMF_RC_NOT_IMPL, &
        msg="This component requires export fields to be defined.", &
        line=__LINE__, file=__FILE__, &
        rcToReturn=rc)
      return  ! bail out
    end if

    ! -- query the Component for its clock, importState and exportState
!    write(6,*)'get states'
!    call flush(6)
    call NUOPC_ModelGet(model, importState=importState, &
      exportState=exportState, modelClock=clock, rc=rc)
!    write(6,*)'get states rc= ',rc
!    call flush(6)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out

    ! get coordinates from Grid object
    ! assume all fields on same grid
    ! use first field 
    call ESMF_StateGet(importState, field=field, &
      itemName=trim(importFieldNames(1)), rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out
    call ESMF_FieldGet(field, geomtype=geomtype, localDeCount=localDeCount, rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out

    if (geomtype == ESMF_GEOMTYPE_GRID) then
      call ESMF_FieldGet(field, grid=grid, array=array, rc=rc)
      if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
        line=__LINE__, &
        file=__FILE__)) &
        return  ! bail out
      call ESMF_ArrayGet(array, deCount=deCount, dimCount=dimCount, &
        tileCount=tileCount, rc=rc)
      if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
        line=__LINE__, &
        file=__FILE__)) &
        return  ! bail out
      allocate(minIndexPDe(dimCount, deCount), maxIndexPDe(dimCount, deCount),  &
        minIndexPTile(dimCount, tileCount), maxIndexPTile(dimCount, tileCount), &
        computationalLBound(dimCount, localDeCount), computationalUBound(dimCount, localDeCount), &
        deToTileMap(deCount), localDeToDeMap(localDeCount), stat=localrc)
      if (ESMF_LogFoundAllocError(statusToCheck=localrc, msg=ESMF_LOGERR_PASSTHRU, &
        line=__LINE__,  &
        file=__FILE__,  &
        rcToReturn=rc)) &
        return  ! bail out
      call ESMF_ArrayGet(array, distgrid=distgrid, &
        deToTileMap=deToTileMap, localDeToDeMap=localDeToDeMap, &
        computationalLBound=computationalLBound, &
        computationalUBound=computationalUBound, rc=rc)
      if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
        line=__LINE__, &
        file=__FILE__)) &
        return  ! bail out
      call ESMF_DistGridGet(distgrid, &
        minIndexPDe=minIndexPDe, maxIndexPDe=maxIndexPDe, &
        minIndexPTile=minIndexPTile, maxIndexPTile=maxIndexPTile, &
        rc=rc)
      if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
        line=__LINE__, &
        file=__FILE__)) &
        return  ! bail out

      ! -- init chemistry model on local DEs
      call raqmschem_model_create(deCount=localDeCount, rc=rc)
      if(rc/=0)then
        write(6,*)'raqmschem_model_create rc',rc
        call flush(6)
      endif
      if (chem_rc_check(rc)) then
        call ESMF_LogSetError(ESMF_RC_INTNRL_BAD, &
          msg="Failed to initialize chemistry model for localDeCount", &
          line=__LINE__, &
          file=__FILE__, &
          rcToReturn=rc)
        return  ! bail out
      end if

      call ESMF_VMGet(vm, localPet=localPet, rc=rc)
      if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
        line=__LINE__, &
        file=__FILE__)) &
        return  ! bail out

      do localDe = 0, localDeCount-1
        de   = localDeToDeMap(localDe+1) + 1
        tile = deToTileMap(de)

        if (btest(verbosity,0)) then
          write(msgString,'("RCHM: localDe: ",i4," DE: ",i4, " tile=",i2," minIndexPDe=",2i4,2x," maxIndexPDe=",2i4," minIndexPTile=",2i4," maxIndexPTile=",2i4,4i4)') &
            localDe, de-1, tile, minIndexPDe(:,de), maxIndexPDe(:,de), minIndexPTile(:,tile), maxIndexPTile(:,tile), &
            computationalLBound(:,localDe+1), computationalUBound(:,localDe+1)
          call ESMF_LogWrite(trim(msgString), ESMF_LOGMSG_INFO, rc=rc)
          if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
            line=__LINE__, &
            file=__FILE__)) &
            return  ! bail out
        end if

        ! -- set model domains for local DEs
        call raqmschem_model_domain_set(minIndexPDe=minIndexPDe(:,de), maxIndexPDe=maxIndexPDe(:,de), &
          minIndexPTile=minIndexPTile(:,tile), maxIndexPTile=maxIndexPTile(:,tile), &
          minIndexLocal=computationalLBound(:,localDe+1), maxIndexLocal=computationalUBound(:,localDe+1), &
          tile=deToTileMap(de), tileCount=tileCount, de=localDe, rc=rc)
        if (chem_rc_check(rc)) then
          call ESMF_LogSetError(ESMF_RC_INTNRL_BAD, &
            msg="Failed to set domain for chemistry model", &
            line=__LINE__, &
            file=__FILE__, &
            rcToReturn=rc)
          return  ! bail out
        end if

        ! -- get local coordinate arrays
        do item = 1, 2
          call ESMF_GridGetCoord(grid, coordDim=item, staggerloc=ESMF_STAGGERLOC_CENTER, &
            localDE=localDe, farrayPtr=coord, rc=rc)
          if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
            line=__LINE__, &
            file=__FILE__)) &
            return  ! bail out
          call chem_model_domain_coord_set(item, coord, de=localDe, rc=rc)
          if (chem_rc_check(rc)) then
            call ESMF_LogSetError(ESMF_RC_INTNRL_BAD, &
              msg="Failed to set coordinates for chemistry model", &
              line=__LINE__, &
              file=__FILE__, &
              rcToReturn=rc)
            return  ! bail out
          end if
        end do

      end do
      deallocate(minIndexPDe, maxIndexPDe, minIndexPTile, maxIndexPTile, &
        computationalLBound, computationalUBound, &
        deToTileMap, localDeToDeMap, stat=localrc)
      if (ESMF_LogFoundDeallocError(statusToCheck=localrc, msg=ESMF_LOGERR_PASSTHRU, &
        line=__LINE__,  &
        file=__FILE__,  &
        rcToReturn=rc)) &
        return  ! bail out

    else
      call ESMF_LogSetError(ESMF_RC_NOT_IMPL, &
        msg="Imported fields can only be defined on Grid objects.", &
        line=__LINE__, file=__FILE__, &
        rcToReturn=rc)
      return  ! bail out
    end if

    ! -- init model communication subsystem over ESMF communicator
    call ESMF_GridCompGet(model, vm=vm, rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out
    call ESMF_VMGet(vm, mpiCommunicator=comm, rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out

    ! -- initialize model after creation to setup correct communication
!    write(6,*)'ajl call chem_model_init'
!    call flush(6)
    call chem_model_init(comm=comm, isolate=.true., rc=rc)
    if (chem_rc_check(rc)) then
      call ESMF_LogSetError(ESMF_RC_INTNRL_BAD, &
        msg="Failed to initialize chemistry model", &
        line=__LINE__, &
        file=__FILE__, &
        rcToReturn=rc)
      return  ! bail out
    end if

    ! -- initialize model I/O
    call raqmschem_io_init(rc=rc)
!    write(6,*)'rc zz ',rc
!    call flush(6)
    if (chem_rc_check(rc)) then
      call ESMF_LogSetError(ESMF_RC_INTNRL_BAD, &
        msg="Failed to initialize I/O model subsystem", &
        line=__LINE__, &
        file=__FILE__, &
        rcToReturn=rc)
      return  ! bail out
    end if

    ! -- read-in emission and background fields, setup internal parameters
    call chem_model_config_init(rc=rc)
!    write(6,*)'ajl aft config_init',rc
!    call flush(6)
    if (chem_rc_check(rc)) then
      call ESMF_LogSetError(ESMF_RC_INTNRL_BAD, &
        msg="Failed to initialize model configuration", &
        line=__LINE__, &
        file=__FILE__, &
        rcToReturn=rc)
      return  ! bail out
    end if

    ! -- initialize internal clock
    ! -- get clock information
    call ESMF_ClockGet(clock, startTime=startTime, timeStep=timeStep, rc=localrc)
    if (ESMF_LogFoundError(rcToCheck=localrc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__,  &
      file=__FILE__,  &
      rcToReturn=rc)) &
      return  ! bail out
    ! -- get forecast initial time
    call ESMF_TimeGet(startTime, yy=yy, mm=mm, dd=dd, h=h, m=m, rc=localrc)
    if (ESMF_LogFoundError(rcToCheck=localrc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__,  &
      file=__FILE__,  &
      rcToReturn=rc)) &
      return  ! bail out
    ! -- get time step
    call ESMF_TimeIntervalGet(timeStep, s_r8=dts, rc=localrc)
    if (ESMF_LogFoundError(rcToCheck=localrc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__,  &
      file=__FILE__,  &
      rcToReturn=rc)) &
      return  ! bail out
    ! -- set internal clock
!    write(6,*)'ajl call chemmodelclockcreate'
!    call flush(6)
    call chem_model_clock_create(rc=rc)
    if (chem_rc_check(rc)) then
      call ESMF_LogSetError(ESMF_RC_INTNRL_BAD, &
        msg="Failed to create model clock", &
        line=__LINE__, &
        file=__FILE__, &
        rcToReturn=rc)
      return  ! bail out
    end if
    call chem_model_clock_set(yy=yy, mm=mm, dd=dd, h=h, m=m,  &
     dts=real(dts,kind=CHEM_KIND_R8), tz=0, rc=rc)
    if (chem_rc_check(rc)) then
      call ESMF_LogSetError(ESMF_RC_INTNRL_BAD, &
        msg="Failed to initialize model clock", &
        line=__LINE__, &
        file=__FILE__, &
        rcToReturn=rc)
      return  ! bail out
    end if
    call chem_comm_get(localpe=mype)
    if(mype.eq.0)then
      write(6,*)'raqmschemap dts',dts,' yy ',yy,' mm ',mm,' dd ',dd,' h ',h,' m ',m
      call flush(6)
    endif


    ! -- connect import fields to model
    ! -- this can be done only once since remote fields are accessed by reference
!    write(6,*)'ajl call chemcompocon import'
!    call flush(6)
!   ajl this sets nl so could raqmschempmgrid set after this
    call raqmschem_comp_connect('import', importState, importFieldNames, rc)
!    write(6,*)'connect',rc
!    call flush(6)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out

    ! -- connect export fields to model
    ! -- this can be done only once since remote fields are accessed by reference
!    write(6,*)'raqmschem_comp_connect exprot'
!    call flush(6)
    call raqmschem_comp_connect('export', exportState, exportFieldNames, rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out
    ! -- allocate memory for internal workspace
!    write(6,*)'call backgd_init'
!    call flush(6)
    call raqmschem_backgd_init(rc=rc)
!    write(6,*)'didd init',rc
!    call flush(6)
    if (chem_rc_check(rc)) then
      call ESMF_LogSetError(ESMF_RC_INTNRL_BAD, &
        msg="Failed to initialize I/O model subsystem", &
        line=__LINE__, &
        file=__FILE__, &
        rcToReturn=rc)
      return  ! bail out
    end if

    ! -- read-in emission and background fields
    call raqmschem_backgd_read(yy,mm,dd,bigendian=bigendian,rc=rc)
    
    if (chem_rc_check(rc)) then
      write(6,*)'error zz '
      call flush(6)
      call ESMF_LogSetError(ESMF_RC_INTNRL_BAD, &
        msg="Failed to initialize I/O model subsystem", &
        line=__LINE__, &
        file=__FILE__, &
        rcToReturn=rc)
      return  ! bail out
    end if

!   #if 0
    ! -- diagnostics: write out emission and background fields
    call raqmschem_backgd_write(rc=rc)
    if (chem_rc_check(rc)) then
      write(6,*)'error yy'
      call flush(6)
      call ESMF_LogSetError(ESMF_RC_INTNRL_BAD, &
        msg="Failed to initialize I/O model subsystem", &
        line=__LINE__, &
        file=__FILE__, &
        rcToReturn=rc)
      return  ! bail out
    end if
!   #endif

    ! -- initialize internal component (GOCART)
!    write(6,*)'ajl cchemcomp init'
!    call flush(6)
    call raqmschem_comp_init(rc=rc)
!    write(6,*)'ajl did cchemcomp init',rc
!    call flush(6)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out

#if 0
    ! -- allocate arrays for tracer output
    call raqmschem_output_init(rc=rc)
    if (chem_rc_check(rc)) then
      call ESMF_LogSetError(ESMF_RC_INTNRL_BAD, &
        msg="Failed to allocate output arrays", &
        line=__LINE__, &
        file=__FILE__, &
        rcToReturn=rc)
      return  ! bail out
    end if
#endif

    ! indicate that data initialization is complete (breaking out of init-loop)
!    write(6,*)'ajl nuopccompattste'
!    call flush(6)
    call NUOPC_CompAttributeSet(model, &
      name="InitializeDataComplete", value="true", rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out
!    write(6,*)'ajl raqms bot datainitialize',rc
!    call flush(6)

  end subroutine raqDataInitialize

  !-----------------------------------------------------------------------------

  subroutine raqModelAdvance(model, rc)
    use raqmschem_iodata_mod
    use chem_comm_mod, only : chem_comm_get
    type(ESMF_GridComp)  :: model
    integer, intent(out) :: rc
   
    
    ! local variables
    type(ESMF_Clock)              :: clock
    type(ESMF_State)              :: importState, exportState
    type(ESMF_Time)               :: currTime
    type(ESMF_TimeInterval)       :: timeStep
    type(ESMF_Field)              :: field
    type(ESMF_VM)                 :: vm
    integer                       :: item
    integer mype

    ! begin
    rc = ESMF_SUCCESS
    
    ! query the Component for its clock, importState and exportState
!     write(6,*)'ajl top raqmschem modeladvance 8.7'
!    write(0,*)'ajl top raqmschem modeladvance 8.7'
     call flush(6)
    call flush(0)
    call NUOPC_ModelGet(model, modelClock=clock, importState=importState, &
      exportState=exportState, rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out

    ! HERE THE MODEL ADVANCES: currTime -> currTime + timeStep
    
    ! Because of the way that the internal Clock was set in SetClock(),
    ! its timeStep is likely smaller than the parent timeStep. As a consequence
    ! the time interval covered by a single parent timeStep will result in 
    ! multiple calls to the ModelAdvance() routine. Every time the currTime
    ! will come in by one internal timeStep advanced. This goes until the
    ! stopTime of the internal Clock has been reached.
    call chem_comm_get(localpe=mype)
    if(mype.eq.0)then 
      call ESMF_ClockPrint(clock, options="currTime", &
      preString="------>Advancing RCHM from: ", rc=rc)
      if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out
    endif
    
    call ESMF_ClockGet(clock, currTime=currTime, timeStep=timeStep, rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out
    
    if(mype.eq.0)then 
      call ESMF_TimePrint(currTime + timeStep, &
      preString="--------------------------------> to: ", rc=rc)
      if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out
    endif

    ! print field diagnostics
    if (btest(verbosity,0)) then
      call ESMF_GridCompGet(model, vm=vm, rc=rc)
      if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
        line=__LINE__, &
        file=__FILE__)) &
        return  ! bail out
      do item = 1, importFieldCount
!        write(6,*)'item',item,trim(importFieldNames(item))
!        call flush(6)
        call ESMF_StateGet(importState, field=field, &
          itemName=trim(importFieldNames(item)), rc=rc)
        if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
          line=__LINE__, &
          file=__FILE__)) &
          return  ! bail out
!        write(6,*)'raqms fieldprintminmax',item,trim(importFieldNames(item))
!        call flush(6)
        call fieldPrintMinMax(field, vm=vm, rc=rc)
        if(rc/=0)then
          write(6,*)'error field',trim(importFieldNames(item))
          call flush(6)
        endif
        if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
          line=__LINE__, &
          file=__FILE__)) &
          return  ! bail out
      end do
    end if

    ! advance model
!    write(6,*)'ajl call raqms advance '
!    call flush(6)
    call raqmschem_comp_advance(clock, rc)
!    write(6,*)'ajl did call raqms advance ',rc
!    call flush(6)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out

    ! write output if it is time
#if 0
    call raqmschem_output_write(rc)
    if (chem_rc_check(rc)) then
      call ESMF_LogSetError(ESMF_RC_INTNRL_BAD, &
        msg="Failed to write chemistry output", &
        line=__LINE__, &
        file=__FILE__, &
        rcToReturn=rc)
      return  ! bail out
    end if
    call raqmschem_backgd_write(rc=rc)
    if (chem_rc_check(rc)) then
      call ESMF_LogSetError(ESMF_RC_INTNRL_BAD, &
        msg="Failed to initialize I/O model subsystem", &
        line=__LINE__, &
        file=__FILE__, &
        rcToReturn=rc)
      return  ! bail out
    end if
#endif
!  write(6,*)'ajl bottom raqms modeladvance 8.7'
!  call flush(6)

  end subroutine raqModelAdvance
! new code from April 4 2018 version to support chem_between

  subroutine raqCheckImport(model, rc) 
    type(ESMF_GridComp)   :: model
    integer, intent(out)  :: rc
    
    ! Enforce a time dependency on the imported fields to be a coupling
    ! timeStep ahead of the current time. This means that the chemistry
    ! component is assumed to run sequentially after the ATM during the 
    ! same timestep. An incorrect run sequence will be flagged here as an
    ! incompatibility.
    
    ! local variables
    type(ESMF_Clock)        :: clock
    type(ESMF_Time)         :: time
    type(ESMF_State)        :: importState
    logical                 :: allCurrent

    rc = ESMF_SUCCESS
!    write(6,*)'ajl raqms checkimport'
!    call flush(6)
    
    ! query the Component for its clock and importState
    call NUOPC_ModelGet(model, modelClock=clock, importState=importState, rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out 

    ! get the current time out of the clock
    call ESMF_ClockGet(clock, stopTime=time, rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out 
    
    ! check that Fields in the importState show correct timestamp
    allCurrent = NUOPC_IsAtTime(importState, time, rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out 
    
    if (.not.allCurrent) then
      !TODO: introduce and use INCOMPATIBILITY return codes!!!!
      call ESMF_LogSetError(ESMF_RC_ARG_BAD, &
        msg="NUOPC INCOMPATIBILITY DETECTED: Import Fields not at the "// &
        "expected time", &
        line=__LINE__, &
        file=__FILE__, &
        rcToReturn=rc)
      return  ! bail out 
    endif
    
  end subroutine

  subroutine ModelFinalize(model, rc)
    type(ESMF_GridComp)   :: model
    integer, intent(out)  :: rc

    ! begin
    rc = ESMF_SUCCESS

    ! finalize model
    call raqmschem_comp_finalize(rc)

  end subroutine ModelFinalize

end module RAQMSCHM
  subroutine raqmstest
      write(6,*)'raqmstest'
      call flush(6)
  end subroutine raqmstest
